// Code generated by mockery v2.14.0. DO NOT EDIT.

package mocks

import (
	clobtypes "github.com/dydxprotocol/v4/x/clob/types"
	mock "github.com/stretchr/testify/mock"

	perpetualstypes "github.com/dydxprotocol/v4/x/perpetuals/types"

	subaccountstypes "github.com/dydxprotocol/v4/x/subaccounts/types"

	types "github.com/cosmos/cosmos-sdk/types"
)

// MemClob is an autogenerated mock type for the MemClob type
type MemClob struct {
	mock.Mock
}

// CancelOrder provides a mock function with given fields: ctx, msgCancelOrder
func (_m *MemClob) CancelOrder(ctx types.Context, msgCancelOrder *clobtypes.MsgCancelOrder) (*clobtypes.OffchainUpdates, error) {
	ret := _m.Called(ctx, msgCancelOrder)

	var r0 *clobtypes.OffchainUpdates
	if rf, ok := ret.Get(0).(func(types.Context, *clobtypes.MsgCancelOrder) *clobtypes.OffchainUpdates); ok {
		r0 = rf(ctx, msgCancelOrder)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clobtypes.OffchainUpdates)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Context, *clobtypes.MsgCancelOrder) error); ok {
		r1 = rf(ctx, msgCancelOrder)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateOrderbook provides a mock function with given fields: ctx, clobPair
func (_m *MemClob) CreateOrderbook(ctx types.Context, clobPair clobtypes.ClobPair) {
	_m.Called(ctx, clobPair)
}

// GetCancelOrder provides a mock function with given fields: ctx, orderId
func (_m *MemClob) GetCancelOrder(ctx types.Context, orderId clobtypes.OrderId) (uint32, bool) {
	ret := _m.Called(ctx, orderId)

	var r0 uint32
	if rf, ok := ret.Get(0).(func(types.Context, clobtypes.OrderId) uint32); ok {
		r0 = rf(ctx, orderId)
	} else {
		r0 = ret.Get(0).(uint32)
	}

	var r1 bool
	if rf, ok := ret.Get(1).(func(types.Context, clobtypes.OrderId) bool); ok {
		r1 = rf(ctx, orderId)
	} else {
		r1 = ret.Get(1).(bool)
	}

	return r0, r1
}

// GetClobPairForPerpetual provides a mock function with given fields: ctx, perptualId
func (_m *MemClob) GetClobPairForPerpetual(ctx types.Context, perptualId uint32) (clobtypes.ClobPairId, error) {
	ret := _m.Called(ctx, perptualId)

	var r0 clobtypes.ClobPairId
	if rf, ok := ret.Get(0).(func(types.Context, uint32) clobtypes.ClobPairId); ok {
		r0 = rf(ctx, perptualId)
	} else {
		r0 = ret.Get(0).(clobtypes.ClobPairId)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Context, uint32) error); ok {
		r1 = rf(ctx, perptualId)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetOperations provides a mock function with given fields: ctx
func (_m *MemClob) GetOperations(ctx types.Context) []clobtypes.Operation {
	ret := _m.Called(ctx)

	var r0 []clobtypes.Operation
	if rf, ok := ret.Get(0).(func(types.Context) []clobtypes.Operation); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]clobtypes.Operation)
		}
	}

	return r0
}

// GetOrder provides a mock function with given fields: ctx, orderId
func (_m *MemClob) GetOrder(ctx types.Context, orderId clobtypes.OrderId) (clobtypes.Order, bool) {
	ret := _m.Called(ctx, orderId)

	var r0 clobtypes.Order
	if rf, ok := ret.Get(0).(func(types.Context, clobtypes.OrderId) clobtypes.Order); ok {
		r0 = rf(ctx, orderId)
	} else {
		r0 = ret.Get(0).(clobtypes.Order)
	}

	var r1 bool
	if rf, ok := ret.Get(1).(func(types.Context, clobtypes.OrderId) bool); ok {
		r1 = rf(ctx, orderId)
	} else {
		r1 = ret.Get(1).(bool)
	}

	return r0, r1
}

// GetOrderFilledAmount provides a mock function with given fields: ctx, orderId
func (_m *MemClob) GetOrderFilledAmount(ctx types.Context, orderId clobtypes.OrderId) subaccountstypes.BaseQuantums {
	ret := _m.Called(ctx, orderId)

	var r0 subaccountstypes.BaseQuantums
	if rf, ok := ret.Get(0).(func(types.Context, clobtypes.OrderId) subaccountstypes.BaseQuantums); ok {
		r0 = rf(ctx, orderId)
	} else {
		r0 = ret.Get(0).(subaccountstypes.BaseQuantums)
	}

	return r0
}

// GetOrdersWithAddToOrderbookCollatCheck provides a mock function with given fields: ctx
func (_m *MemClob) GetOrdersWithAddToOrderbookCollatCheck(ctx types.Context) []clobtypes.OrderHash {
	ret := _m.Called(ctx)

	var r0 []clobtypes.OrderHash
	if rf, ok := ret.Get(0).(func(types.Context) []clobtypes.OrderHash); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]clobtypes.OrderHash)
		}
	}

	return r0
}

// GetPricePremium provides a mock function with given fields: ctx, clobPair, params
func (_m *MemClob) GetPricePremium(ctx types.Context, clobPair clobtypes.ClobPair, params perpetualstypes.GetPricePremiumParams) (int32, error) {
	ret := _m.Called(ctx, clobPair, params)

	var r0 int32
	if rf, ok := ret.Get(0).(func(types.Context, clobtypes.ClobPair, perpetualstypes.GetPricePremiumParams) int32); ok {
		r0 = rf(ctx, clobPair, params)
	} else {
		r0 = ret.Get(0).(int32)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Context, clobtypes.ClobPair, perpetualstypes.GetPricePremiumParams) error); ok {
		r1 = rf(ctx, clobPair, params)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetSubaccountOrders provides a mock function with given fields: ctx, clobPairId, subaccountId, side
func (_m *MemClob) GetSubaccountOrders(ctx types.Context, clobPairId clobtypes.ClobPairId, subaccountId subaccountstypes.SubaccountId, side clobtypes.Order_Side) ([]clobtypes.Order, error) {
	ret := _m.Called(ctx, clobPairId, subaccountId, side)

	var r0 []clobtypes.Order
	if rf, ok := ret.Get(0).(func(types.Context, clobtypes.ClobPairId, subaccountstypes.SubaccountId, clobtypes.Order_Side) []clobtypes.Order); ok {
		r0 = rf(ctx, clobPairId, subaccountId, side)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]clobtypes.Order)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Context, clobtypes.ClobPairId, subaccountstypes.SubaccountId, clobtypes.Order_Side) error); ok {
		r1 = rf(ctx, clobPairId, subaccountId, side)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PlaceOrder provides a mock function with given fields: ctx, order, performAddToOrderbookCollatCheck
func (_m *MemClob) PlaceOrder(ctx types.Context, order clobtypes.Order, performAddToOrderbookCollatCheck bool) (subaccountstypes.BaseQuantums, clobtypes.OrderStatus, *clobtypes.OffchainUpdates, error) {
	ret := _m.Called(ctx, order, performAddToOrderbookCollatCheck)

	var r0 subaccountstypes.BaseQuantums
	if rf, ok := ret.Get(0).(func(types.Context, clobtypes.Order, bool) subaccountstypes.BaseQuantums); ok {
		r0 = rf(ctx, order, performAddToOrderbookCollatCheck)
	} else {
		r0 = ret.Get(0).(subaccountstypes.BaseQuantums)
	}

	var r1 clobtypes.OrderStatus
	if rf, ok := ret.Get(1).(func(types.Context, clobtypes.Order, bool) clobtypes.OrderStatus); ok {
		r1 = rf(ctx, order, performAddToOrderbookCollatCheck)
	} else {
		r1 = ret.Get(1).(clobtypes.OrderStatus)
	}

	var r2 *clobtypes.OffchainUpdates
	if rf, ok := ret.Get(2).(func(types.Context, clobtypes.Order, bool) *clobtypes.OffchainUpdates); ok {
		r2 = rf(ctx, order, performAddToOrderbookCollatCheck)
	} else {
		if ret.Get(2) != nil {
			r2 = ret.Get(2).(*clobtypes.OffchainUpdates)
		}
	}

	var r3 error
	if rf, ok := ret.Get(3).(func(types.Context, clobtypes.Order, bool) error); ok {
		r3 = rf(ctx, order, performAddToOrderbookCollatCheck)
	} else {
		r3 = ret.Error(3)
	}

	return r0, r1, r2, r3
}

// PlacePerpetualLiquidation provides a mock function with given fields: ctx, liquidationOrder
func (_m *MemClob) PlacePerpetualLiquidation(ctx types.Context, liquidationOrder clobtypes.LiquidationOrder) (subaccountstypes.BaseQuantums, clobtypes.OrderStatus, *clobtypes.OffchainUpdates, error) {
	ret := _m.Called(ctx, liquidationOrder)

	var r0 subaccountstypes.BaseQuantums
	if rf, ok := ret.Get(0).(func(types.Context, clobtypes.LiquidationOrder) subaccountstypes.BaseQuantums); ok {
		r0 = rf(ctx, liquidationOrder)
	} else {
		r0 = ret.Get(0).(subaccountstypes.BaseQuantums)
	}

	var r1 clobtypes.OrderStatus
	if rf, ok := ret.Get(1).(func(types.Context, clobtypes.LiquidationOrder) clobtypes.OrderStatus); ok {
		r1 = rf(ctx, liquidationOrder)
	} else {
		r1 = ret.Get(1).(clobtypes.OrderStatus)
	}

	var r2 *clobtypes.OffchainUpdates
	if rf, ok := ret.Get(2).(func(types.Context, clobtypes.LiquidationOrder) *clobtypes.OffchainUpdates); ok {
		r2 = rf(ctx, liquidationOrder)
	} else {
		if ret.Get(2) != nil {
			r2 = ret.Get(2).(*clobtypes.OffchainUpdates)
		}
	}

	var r3 error
	if rf, ok := ret.Get(3).(func(types.Context, clobtypes.LiquidationOrder) error); ok {
		r3 = rf(ctx, liquidationOrder)
	} else {
		r3 = ret.Error(3)
	}

	return r0, r1, r2, r3
}

// PurgeInvalidMemclobState provides a mock function with given fields: ctx, fullyFilledOrderIds, expiredStatefulOrderIds, canceledStatefulOrderIds, existingOffchainUpdates
func (_m *MemClob) PurgeInvalidMemclobState(ctx types.Context, fullyFilledOrderIds []clobtypes.OrderId, expiredStatefulOrderIds []clobtypes.OrderId, canceledStatefulOrderIds []clobtypes.OrderId, existingOffchainUpdates *clobtypes.OffchainUpdates) *clobtypes.OffchainUpdates {
	ret := _m.Called(ctx, fullyFilledOrderIds, expiredStatefulOrderIds, canceledStatefulOrderIds, existingOffchainUpdates)

	var r0 *clobtypes.OffchainUpdates
	if rf, ok := ret.Get(0).(func(types.Context, []clobtypes.OrderId, []clobtypes.OrderId, []clobtypes.OrderId, *clobtypes.OffchainUpdates) *clobtypes.OffchainUpdates); ok {
		r0 = rf(ctx, fullyFilledOrderIds, expiredStatefulOrderIds, canceledStatefulOrderIds, existingOffchainUpdates)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clobtypes.OffchainUpdates)
		}
	}

	return r0
}

// RemoveAndClearOperationsQueue provides a mock function with given fields: ctx, localValidatorOperationsQueue
func (_m *MemClob) RemoveAndClearOperationsQueue(ctx types.Context, localValidatorOperationsQueue []clobtypes.Operation) {
	_m.Called(ctx, localValidatorOperationsQueue)
}

// RemoveOrderIfFilled provides a mock function with given fields: ctx, orderId
func (_m *MemClob) RemoveOrderIfFilled(ctx types.Context, orderId clobtypes.OrderId) {
	_m.Called(ctx, orderId)
}

// ReplayOperations provides a mock function with given fields: ctx, localOperationsQueue, existingOffchainUpdates, canceledStatefulOrderIds
func (_m *MemClob) ReplayOperations(ctx types.Context, localOperationsQueue []clobtypes.Operation, existingOffchainUpdates *clobtypes.OffchainUpdates, canceledStatefulOrderIds []clobtypes.OrderId) *clobtypes.OffchainUpdates {
	ret := _m.Called(ctx, localOperationsQueue, existingOffchainUpdates, canceledStatefulOrderIds)

	var r0 *clobtypes.OffchainUpdates
	if rf, ok := ret.Get(0).(func(types.Context, []clobtypes.Operation, *clobtypes.OffchainUpdates, []clobtypes.OrderId) *clobtypes.OffchainUpdates); ok {
		r0 = rf(ctx, localOperationsQueue, existingOffchainUpdates, canceledStatefulOrderIds)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*clobtypes.OffchainUpdates)
		}
	}

	return r0
}

// SetClobKeeper provides a mock function with given fields: keeper
func (_m *MemClob) SetClobKeeper(keeper clobtypes.MemClobKeeper) {
	_m.Called(keeper)
}

type mockConstructorTestingTNewMemClob interface {
	mock.TestingT
	Cleanup(func())
}

// NewMemClob creates a new instance of MemClob. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewMemClob(t mockConstructorTestingTNewMemClob) *MemClob {
	mock := &MemClob{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
