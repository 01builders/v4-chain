// Code generated by mockery v2.14.0. DO NOT EDIT.

package mocks

import (
	pricestypes "github.com/dydxprotocol/v4/x/prices/types"
	mock "github.com/stretchr/testify/mock"

	types "github.com/cosmos/cosmos-sdk/types"
)

// PricesKeeper is an autogenerated mock type for the PricesKeeper type
type PricesKeeper struct {
	mock.Mock
}

// CreateExchangeFeed provides a mock function with given fields: ctx, name, memo
func (_m *PricesKeeper) CreateExchangeFeed(ctx types.Context, name string, memo string) (pricestypes.ExchangeFeed, error) {
	ret := _m.Called(ctx, name, memo)

	var r0 pricestypes.ExchangeFeed
	if rf, ok := ret.Get(0).(func(types.Context, string, string) pricestypes.ExchangeFeed); ok {
		r0 = rf(ctx, name, memo)
	} else {
		r0 = ret.Get(0).(pricestypes.ExchangeFeed)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Context, string, string) error); ok {
		r1 = rf(ctx, name, memo)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateMarket provides a mock function with given fields: ctx, pair, exponent, exchanges, minExchanges, minPriceChangePpm
func (_m *PricesKeeper) CreateMarket(ctx types.Context, pair string, exponent int32, exchanges []uint32, minExchanges uint32, minPriceChangePpm uint32) (pricestypes.Market, error) {
	ret := _m.Called(ctx, pair, exponent, exchanges, minExchanges, minPriceChangePpm)

	var r0 pricestypes.Market
	if rf, ok := ret.Get(0).(func(types.Context, string, int32, []uint32, uint32, uint32) pricestypes.Market); ok {
		r0 = rf(ctx, pair, exponent, exchanges, minExchanges, minPriceChangePpm)
	} else {
		r0 = ret.Get(0).(pricestypes.Market)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Context, string, int32, []uint32, uint32, uint32) error); ok {
		r1 = rf(ctx, pair, exponent, exchanges, minExchanges, minPriceChangePpm)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAllExchangeFeeds provides a mock function with given fields: ctx
func (_m *PricesKeeper) GetAllExchangeFeeds(ctx types.Context) []pricestypes.ExchangeFeed {
	ret := _m.Called(ctx)

	var r0 []pricestypes.ExchangeFeed
	if rf, ok := ret.Get(0).(func(types.Context) []pricestypes.ExchangeFeed); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]pricestypes.ExchangeFeed)
		}
	}

	return r0
}

// GetAllMarkets provides a mock function with given fields: ctx
func (_m *PricesKeeper) GetAllMarkets(ctx types.Context) []pricestypes.Market {
	ret := _m.Called(ctx)

	var r0 []pricestypes.Market
	if rf, ok := ret.Get(0).(func(types.Context) []pricestypes.Market); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]pricestypes.Market)
		}
	}

	return r0
}

// GetExchangeFeed provides a mock function with given fields: ctx, id
func (_m *PricesKeeper) GetExchangeFeed(ctx types.Context, id uint32) (pricestypes.ExchangeFeed, error) {
	ret := _m.Called(ctx, id)

	var r0 pricestypes.ExchangeFeed
	if rf, ok := ret.Get(0).(func(types.Context, uint32) pricestypes.ExchangeFeed); ok {
		r0 = rf(ctx, id)
	} else {
		r0 = ret.Get(0).(pricestypes.ExchangeFeed)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Context, uint32) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetMarket provides a mock function with given fields: ctx, id
func (_m *PricesKeeper) GetMarket(ctx types.Context, id uint32) (pricestypes.Market, error) {
	ret := _m.Called(ctx, id)

	var r0 pricestypes.Market
	if rf, ok := ret.Get(0).(func(types.Context, uint32) pricestypes.Market); ok {
		r0 = rf(ctx, id)
	} else {
		r0 = ret.Get(0).(pricestypes.Market)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Context, uint32) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetNumExchangeFeeds provides a mock function with given fields: ctx
func (_m *PricesKeeper) GetNumExchangeFeeds(ctx types.Context) uint32 {
	ret := _m.Called(ctx)

	var r0 uint32
	if rf, ok := ret.Get(0).(func(types.Context) uint32); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(uint32)
	}

	return r0
}

// GetNumMarkets provides a mock function with given fields: ctx
func (_m *PricesKeeper) GetNumMarkets(ctx types.Context) uint32 {
	ret := _m.Called(ctx)

	var r0 uint32
	if rf, ok := ret.Get(0).(func(types.Context) uint32); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(uint32)
	}

	return r0
}

// ModifyExchangeFeed provides a mock function with given fields: ctx, id, memo
func (_m *PricesKeeper) ModifyExchangeFeed(ctx types.Context, id uint32, memo string) (pricestypes.ExchangeFeed, error) {
	ret := _m.Called(ctx, id, memo)

	var r0 pricestypes.ExchangeFeed
	if rf, ok := ret.Get(0).(func(types.Context, uint32, string) pricestypes.ExchangeFeed); ok {
		r0 = rf(ctx, id, memo)
	} else {
		r0 = ret.Get(0).(pricestypes.ExchangeFeed)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Context, uint32, string) error); ok {
		r1 = rf(ctx, id, memo)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ModifyMarket provides a mock function with given fields: ctx, id, pair, exchanges, minExchanges, minPriceChangePpm
func (_m *PricesKeeper) ModifyMarket(ctx types.Context, id uint32, pair string, exchanges []uint32, minExchanges uint32, minPriceChangePpm uint32) (pricestypes.Market, error) {
	ret := _m.Called(ctx, id, pair, exchanges, minExchanges, minPriceChangePpm)

	var r0 pricestypes.Market
	if rf, ok := ret.Get(0).(func(types.Context, uint32, string, []uint32, uint32, uint32) pricestypes.Market); ok {
		r0 = rf(ctx, id, pair, exchanges, minExchanges, minPriceChangePpm)
	} else {
		r0 = ret.Get(0).(pricestypes.Market)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Context, uint32, string, []uint32, uint32, uint32) error); ok {
		r1 = rf(ctx, id, pair, exchanges, minExchanges, minPriceChangePpm)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PerformStatefulPriceUpdateValidation provides a mock function with given fields: ctx, marketPriceUpdates, performNonDeterministicValidation
func (_m *PricesKeeper) PerformStatefulPriceUpdateValidation(ctx types.Context, marketPriceUpdates *pricestypes.MsgUpdateMarketPrices, performNonDeterministicValidation bool) error {
	ret := _m.Called(ctx, marketPriceUpdates, performNonDeterministicValidation)

	var r0 error
	if rf, ok := ret.Get(0).(func(types.Context, *pricestypes.MsgUpdateMarketPrices, bool) error); ok {
		r0 = rf(ctx, marketPriceUpdates, performNonDeterministicValidation)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateMarketPrices provides a mock function with given fields: ctx, updates, sendIndexerPriceUpdates
func (_m *PricesKeeper) UpdateMarketPrices(ctx types.Context, updates []*pricestypes.MsgUpdateMarketPrices_MarketPrice, sendIndexerPriceUpdates bool) error {
	ret := _m.Called(ctx, updates, sendIndexerPriceUpdates)

	var r0 error
	if rf, ok := ret.Get(0).(func(types.Context, []*pricestypes.MsgUpdateMarketPrices_MarketPrice, bool) error); ok {
		r0 = rf(ctx, updates, sendIndexerPriceUpdates)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateSmoothedPrices provides a mock function with given fields: ctx
func (_m *PricesKeeper) UpdateSmoothedPrices(ctx types.Context) error {
	ret := _m.Called(ctx)

	var r0 error
	if rf, ok := ret.Get(0).(func(types.Context) error); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

type mockConstructorTestingTNewPricesKeeper interface {
	mock.TestingT
	Cleanup(func())
}

// NewPricesKeeper creates a new instance of PricesKeeper. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewPricesKeeper(t mockConstructorTestingTNewPricesKeeper) *PricesKeeper {
	mock := &PricesKeeper{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
