// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: dydxprotocol/perpetuals/perpetual.proto

package types

import (
	fmt "fmt"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	github_com_dydxprotocol_v4_dtypes "github.com/dydxprotocol/v4/dtypes"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Perpetual represents a perpetual on the dYdX exchange.
type Perpetual struct {
	// ==== Non-updatable fields. ====
	// Unique, sequentially-generated.
	Id uint32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// The name of the `Perpetual` (e.g. `BTC-USD`).
	Ticker string `protobuf:"bytes,2,opt,name=ticker,proto3" json:"ticker,omitempty"`
	// The market associated with this `Perpetual`. It
	// acts as the oracle price for the purposes of calculating
	// collateral, margin requirements, and funding rates.
	MarketId uint32 `protobuf:"varint,3,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	// The exponent for converting an atomic amount (`size = 1`)
	// to a full coin. For example, if `AtomicResolution = -8`
	// then a `PerpetualPosition` with `size = 1e8` is equivalent to
	// a position size of one full coin.
	AtomicResolution int32 `protobuf:"zigzag32,4,opt,name=atomic_resolution,json=atomicResolution,proto3" json:"atomic_resolution,omitempty"`
	// ==== Governance-updatable fields. ====
	// The default funding payment if there is no price premium. In
	// parts-per-million.
	DefaultFundingPpm int32 `protobuf:"zigzag32,5,opt,name=default_funding_ppm,json=defaultFundingPpm,proto3" json:"default_funding_ppm,omitempty"`
	// The liquidity_tier that this perpetual is associated with.
	LiquidityTier uint32 `protobuf:"varint,6,opt,name=liquidity_tier,json=liquidityTier,proto3" json:"liquidity_tier,omitempty"`
	// / ==== Regularly-updated fields. ====
	// The current index determined by the cumulative all-time
	// history of the funding mechanism. Starts at zero.
	FundingIndex github_com_dydxprotocol_v4_dtypes.SerializableInt `protobuf:"bytes,7,opt,name=funding_index,json=fundingIndex,proto3,customtype=github.com/dydxprotocol/v4/dtypes.SerializableInt" json:"funding_index"`
	// The total open-interest of the perpetual used for
	// bookkeeping purposes. In base quantums.
	OpenInterest uint64 `protobuf:"varint,8,opt,name=open_interest,json=openInterest,proto3" json:"open_interest,omitempty"`
}

func (m *Perpetual) Reset()         { *m = Perpetual{} }
func (m *Perpetual) String() string { return proto.CompactTextString(m) }
func (*Perpetual) ProtoMessage()    {}
func (*Perpetual) Descriptor() ([]byte, []int) {
	return fileDescriptor_ce7204eee10038be, []int{0}
}
func (m *Perpetual) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Perpetual) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Perpetual.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Perpetual) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Perpetual.Merge(m, src)
}
func (m *Perpetual) XXX_Size() int {
	return m.Size()
}
func (m *Perpetual) XXX_DiscardUnknown() {
	xxx_messageInfo_Perpetual.DiscardUnknown(m)
}

var xxx_messageInfo_Perpetual proto.InternalMessageInfo

func (m *Perpetual) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Perpetual) GetTicker() string {
	if m != nil {
		return m.Ticker
	}
	return ""
}

func (m *Perpetual) GetMarketId() uint32 {
	if m != nil {
		return m.MarketId
	}
	return 0
}

func (m *Perpetual) GetAtomicResolution() int32 {
	if m != nil {
		return m.AtomicResolution
	}
	return 0
}

func (m *Perpetual) GetDefaultFundingPpm() int32 {
	if m != nil {
		return m.DefaultFundingPpm
	}
	return 0
}

func (m *Perpetual) GetLiquidityTier() uint32 {
	if m != nil {
		return m.LiquidityTier
	}
	return 0
}

func (m *Perpetual) GetOpenInterest() uint64 {
	if m != nil {
		return m.OpenInterest
	}
	return 0
}

// MarketPremiums stores a list of premiums for a single perpetual market.
type MarketPremiums struct {
	// perpetual_id is the Id of the perpetual market.
	PerpetualId uint32 `protobuf:"varint,1,opt,name=perpetual_id,json=perpetualId,proto3" json:"perpetual_id,omitempty"`
	// premiums is a list of premium values for a perpetual market. Since most
	// premiums are zeros under "stable" market conditions, only non-zero values
	// are stored in this list.
	Premiums []int32 `protobuf:"zigzag32,2,rep,packed,name=premiums,proto3" json:"premiums,omitempty"`
}

func (m *MarketPremiums) Reset()         { *m = MarketPremiums{} }
func (m *MarketPremiums) String() string { return proto.CompactTextString(m) }
func (*MarketPremiums) ProtoMessage()    {}
func (*MarketPremiums) Descriptor() ([]byte, []int) {
	return fileDescriptor_ce7204eee10038be, []int{1}
}
func (m *MarketPremiums) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MarketPremiums) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MarketPremiums.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MarketPremiums) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MarketPremiums.Merge(m, src)
}
func (m *MarketPremiums) XXX_Size() int {
	return m.Size()
}
func (m *MarketPremiums) XXX_DiscardUnknown() {
	xxx_messageInfo_MarketPremiums.DiscardUnknown(m)
}

var xxx_messageInfo_MarketPremiums proto.InternalMessageInfo

func (m *MarketPremiums) GetPerpetualId() uint32 {
	if m != nil {
		return m.PerpetualId
	}
	return 0
}

func (m *MarketPremiums) GetPremiums() []int32 {
	if m != nil {
		return m.Premiums
	}
	return nil
}

// PremiumStore is a struct to store a perpetual premiums for all
// perpetual markets. It stores a list of `MarketPremiums`, each of which
// corresponds to a perpetual market and stores a list of non-zero premium
// values for that market.
// This struct can either be used to store `PremiumVotes` or
// `PremiumSamples`.
type PremiumStore struct {
	// all_market_premiums a list of `MarketPremiums`, each corresponding to
	// a perpetual market.
	AllMarketPremiums []MarketPremiums `protobuf:"bytes,1,rep,name=all_market_premiums,json=allMarketPremiums,proto3" json:"all_market_premiums"`
	// number of rounds where premium values were added. This value indicates
	// the total number of premiums (zeros and non-zeros) for each
	// `MarketPremiums` struct. Note that in the edge case a perpetual market was
	// added in the middle of a epoch, we don't keep a seperate count for that
	// market. This means we treat this market as having zero premiums before it
	// was added.
	NumPremiums uint32 `protobuf:"varint,2,opt,name=num_premiums,json=numPremiums,proto3" json:"num_premiums,omitempty"`
}

func (m *PremiumStore) Reset()         { *m = PremiumStore{} }
func (m *PremiumStore) String() string { return proto.CompactTextString(m) }
func (*PremiumStore) ProtoMessage()    {}
func (*PremiumStore) Descriptor() ([]byte, []int) {
	return fileDescriptor_ce7204eee10038be, []int{2}
}
func (m *PremiumStore) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PremiumStore) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PremiumStore.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PremiumStore) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PremiumStore.Merge(m, src)
}
func (m *PremiumStore) XXX_Size() int {
	return m.Size()
}
func (m *PremiumStore) XXX_DiscardUnknown() {
	xxx_messageInfo_PremiumStore.DiscardUnknown(m)
}

var xxx_messageInfo_PremiumStore proto.InternalMessageInfo

func (m *PremiumStore) GetAllMarketPremiums() []MarketPremiums {
	if m != nil {
		return m.AllMarketPremiums
	}
	return nil
}

func (m *PremiumStore) GetNumPremiums() uint32 {
	if m != nil {
		return m.NumPremiums
	}
	return 0
}

// LiquidityTier stores margin information.
type LiquidityTier struct {
	// Unique id.
	Id uint32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// The name of the tier purely for mnemonic purposes, e.g. "Gold".
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// The margin fraction needed to open a position.
	// In parts-per-million.
	InitialMarginPpm uint32 `protobuf:"varint,3,opt,name=initial_margin_ppm,json=initialMarginPpm,proto3" json:"initial_margin_ppm,omitempty"`
	// The fraction of the initial-margin that the maintenance-margin is,
	// e.g. 50%. In parts-per-million.
	MaintenanceFractionPpm uint32 `protobuf:"varint,4,opt,name=maintenance_fraction_ppm,json=maintenanceFractionPpm,proto3" json:"maintenance_fraction_ppm,omitempty"`
	// The maximum position size at which the margin requirements are
	// not increased over the default values. Above this position size,
	// the margin requirements increase at a rate of sqrt(size).
	BasePositionNotional uint64 `protobuf:"varint,5,opt,name=base_position_notional,json=basePositionNotional,proto3" json:"base_position_notional,omitempty"`
}

func (m *LiquidityTier) Reset()         { *m = LiquidityTier{} }
func (m *LiquidityTier) String() string { return proto.CompactTextString(m) }
func (*LiquidityTier) ProtoMessage()    {}
func (*LiquidityTier) Descriptor() ([]byte, []int) {
	return fileDescriptor_ce7204eee10038be, []int{3}
}
func (m *LiquidityTier) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LiquidityTier) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LiquidityTier.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LiquidityTier) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LiquidityTier.Merge(m, src)
}
func (m *LiquidityTier) XXX_Size() int {
	return m.Size()
}
func (m *LiquidityTier) XXX_DiscardUnknown() {
	xxx_messageInfo_LiquidityTier.DiscardUnknown(m)
}

var xxx_messageInfo_LiquidityTier proto.InternalMessageInfo

func (m *LiquidityTier) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *LiquidityTier) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *LiquidityTier) GetInitialMarginPpm() uint32 {
	if m != nil {
		return m.InitialMarginPpm
	}
	return 0
}

func (m *LiquidityTier) GetMaintenanceFractionPpm() uint32 {
	if m != nil {
		return m.MaintenanceFractionPpm
	}
	return 0
}

func (m *LiquidityTier) GetBasePositionNotional() uint64 {
	if m != nil {
		return m.BasePositionNotional
	}
	return 0
}

func init() {
	proto.RegisterType((*Perpetual)(nil), "dydxprotocol.perpetuals.Perpetual")
	proto.RegisterType((*MarketPremiums)(nil), "dydxprotocol.perpetuals.MarketPremiums")
	proto.RegisterType((*PremiumStore)(nil), "dydxprotocol.perpetuals.PremiumStore")
	proto.RegisterType((*LiquidityTier)(nil), "dydxprotocol.perpetuals.LiquidityTier")
}

func init() {
	proto.RegisterFile("dydxprotocol/perpetuals/perpetual.proto", fileDescriptor_ce7204eee10038be)
}

var fileDescriptor_ce7204eee10038be = []byte{
	// 561 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x93, 0xc1, 0x6f, 0xd3, 0x3e,
	0x14, 0xc7, 0xeb, 0x2e, 0xbf, 0xfd, 0x36, 0xaf, 0x9d, 0x56, 0x6f, 0x2a, 0xd1, 0x90, 0xb2, 0x50,
	0x84, 0x16, 0x09, 0x48, 0x05, 0xec, 0x00, 0xd7, 0x1e, 0x86, 0x2a, 0x31, 0xa8, 0x32, 0x4e, 0x48,
	0x10, 0xb9, 0xb1, 0x5b, 0xac, 0x39, 0x76, 0x70, 0x1c, 0xd4, 0xf2, 0x57, 0xec, 0xcf, 0xda, 0x71,
	0xdc, 0x80, 0xc3, 0x84, 0xda, 0x7f, 0x04, 0xc5, 0x75, 0xb3, 0x16, 0x04, 0xa7, 0x3e, 0xbf, 0xcf,
	0xf7, 0xbd, 0x3e, 0xbd, 0xf7, 0x0d, 0x3c, 0x26, 0x53, 0x32, 0xc9, 0x94, 0xd4, 0x32, 0x91, 0xbc,
	0x9b, 0x51, 0x95, 0x51, 0x5d, 0x60, 0x9e, 0xdf, 0x86, 0xa1, 0xa1, 0xe8, 0xce, 0xaa, 0x30, 0xbc,
	0x15, 0x1e, 0x1e, 0x8c, 0xe5, 0x58, 0x1a, 0xd0, 0x2d, 0xa3, 0x85, 0xbc, 0xf3, 0xbd, 0x0e, 0xb7,
	0x07, 0x4b, 0x11, 0xda, 0x85, 0x75, 0x46, 0x5c, 0xe0, 0x83, 0xa0, 0x19, 0xd5, 0x19, 0x41, 0x6d,
	0xb8, 0xa9, 0x59, 0x72, 0x41, 0x95, 0x5b, 0xf7, 0x41, 0xb0, 0x1d, 0xd9, 0x17, 0xba, 0x0b, 0xb7,
	0x53, 0xac, 0x2e, 0xa8, 0x8e, 0x19, 0x71, 0x37, 0x8c, 0x7c, 0x6b, 0x91, 0xe8, 0x13, 0xf4, 0x10,
	0xb6, 0xb0, 0x96, 0x29, 0x4b, 0x62, 0x45, 0x73, 0xc9, 0x0b, 0xcd, 0xa4, 0x70, 0x1d, 0x1f, 0x04,
	0xad, 0x68, 0x6f, 0x01, 0xa2, 0x2a, 0x8f, 0x42, 0xb8, 0x4f, 0xe8, 0x08, 0x17, 0x5c, 0xc7, 0xa3,
	0x42, 0x10, 0x26, 0xc6, 0x71, 0x96, 0xa5, 0xee, 0x7f, 0x46, 0xde, 0xb2, 0xe8, 0x74, 0x41, 0x06,
	0x59, 0x8a, 0x1e, 0xc0, 0x5d, 0xce, 0x3e, 0x15, 0x8c, 0x30, 0x3d, 0x8d, 0x35, 0xa3, 0xca, 0xdd,
	0x34, 0x7f, 0xdf, 0xac, 0xb2, 0x6f, 0x19, 0x55, 0xe8, 0x03, 0x6c, 0x2e, 0xdb, 0x31, 0x41, 0xe8,
	0xc4, 0xfd, 0xdf, 0x07, 0x41, 0xa3, 0xf7, 0xe2, 0xea, 0xe6, 0xa8, 0xf6, 0xe3, 0xe6, 0xe8, 0xc9,
	0x98, 0xe9, 0x8f, 0xc5, 0x30, 0x4c, 0x64, 0xda, 0x5d, 0x5b, 0xec, 0xe7, 0x93, 0x2e, 0xd1, 0xd3,
	0x8c, 0xe6, 0xe1, 0x39, 0x55, 0x0c, 0x73, 0xf6, 0x05, 0x0f, 0x39, 0xed, 0x0b, 0x1d, 0x35, 0x6c,
	0xbf, 0x7e, 0xd9, 0x0e, 0xdd, 0x87, 0x4d, 0x99, 0x51, 0x11, 0x33, 0xa1, 0xa9, 0xa2, 0xb9, 0x76,
	0xb7, 0x7c, 0x10, 0x38, 0x51, 0xa3, 0x4c, 0xf6, 0x6d, 0xae, 0xf3, 0x06, 0xee, 0x9e, 0x99, 0xa5,
	0x0c, 0x14, 0x4d, 0x59, 0x91, 0xe6, 0xe8, 0x1e, 0x6c, 0x54, 0x17, 0x89, 0xab, 0x4d, 0xef, 0x54,
	0xb9, 0x3e, 0x41, 0x87, 0x70, 0x2b, 0xb3, 0x72, 0xb7, 0xee, 0x6f, 0x04, 0xad, 0xa8, 0x7a, 0x77,
	0x2e, 0x01, 0x6c, 0xd8, 0x5e, 0xe7, 0x5a, 0x2a, 0x8a, 0xde, 0xc3, 0x7d, 0xcc, 0x79, 0x6c, 0x6f,
	0x51, 0xd5, 0x01, 0x7f, 0x23, 0xd8, 0x79, 0x7a, 0x1c, 0xfe, 0xc5, 0x0a, 0xe1, 0xfa, 0x54, 0x3d,
	0xa7, 0xdc, 0x4a, 0xd4, 0xc2, 0x9c, 0xff, 0x39, 0xae, 0x28, 0xd2, 0x78, 0x65, 0x1e, 0x33, 0xae,
	0x28, 0xd2, 0xa5, 0xa4, 0xf3, 0x15, 0xc0, 0xe6, 0xab, 0xb5, 0xd5, 0xff, 0xee, 0x21, 0x04, 0x1d,
	0x81, 0x53, 0x6a, 0x1d, 0x64, 0x62, 0xf4, 0x08, 0x22, 0x26, 0x98, 0x66, 0xd8, 0xcc, 0x3e, 0x66,
	0xc2, 0x1c, 0x7d, 0x61, 0xa4, 0x3d, 0x4b, 0xce, 0x0c, 0x28, 0x6f, 0xfe, 0x1c, 0xba, 0x29, 0x2e,
	0x37, 0x2d, 0xb0, 0x48, 0x68, 0x3c, 0x52, 0x38, 0x29, 0xbd, 0x63, 0x6a, 0x1c, 0x53, 0xd3, 0x5e,
	0xe1, 0xa7, 0x16, 0x97, 0x95, 0x27, 0xb0, 0x3d, 0xc4, 0x39, 0x8d, 0x33, 0x99, 0x33, 0x53, 0x22,
	0x64, 0xf9, 0x83, 0xb9, 0x31, 0x98, 0x13, 0x1d, 0x94, 0x74, 0x60, 0xe1, 0x6b, 0xcb, 0x7a, 0x2f,
	0xaf, 0x66, 0x1e, 0xb8, 0x9e, 0x79, 0xe0, 0xe7, 0xcc, 0x03, 0x97, 0x73, 0xaf, 0x76, 0x3d, 0xf7,
	0x6a, 0xdf, 0xe6, 0x5e, 0xed, 0xdd, 0xe3, 0x7f, 0xf8, 0x66, 0xb2, 0xfa, 0x55, 0x1a, 0x0f, 0x0d,
	0x37, 0x0d, 0x7f, 0xf6, 0x2b, 0x00, 0x00, 0xff, 0xff, 0xb9, 0x49, 0x20, 0x45, 0xbd, 0x03, 0x00,
	0x00,
}

func (m *Perpetual) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Perpetual) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Perpetual) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OpenInterest != 0 {
		i = encodeVarintPerpetual(dAtA, i, uint64(m.OpenInterest))
		i--
		dAtA[i] = 0x40
	}
	{
		size := m.FundingIndex.Size()
		i -= size
		if _, err := m.FundingIndex.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintPerpetual(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	if m.LiquidityTier != 0 {
		i = encodeVarintPerpetual(dAtA, i, uint64(m.LiquidityTier))
		i--
		dAtA[i] = 0x30
	}
	if m.DefaultFundingPpm != 0 {
		i = encodeVarintPerpetual(dAtA, i, uint64((uint32(m.DefaultFundingPpm)<<1)^uint32((m.DefaultFundingPpm>>31))))
		i--
		dAtA[i] = 0x28
	}
	if m.AtomicResolution != 0 {
		i = encodeVarintPerpetual(dAtA, i, uint64((uint32(m.AtomicResolution)<<1)^uint32((m.AtomicResolution>>31))))
		i--
		dAtA[i] = 0x20
	}
	if m.MarketId != 0 {
		i = encodeVarintPerpetual(dAtA, i, uint64(m.MarketId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Ticker) > 0 {
		i -= len(m.Ticker)
		copy(dAtA[i:], m.Ticker)
		i = encodeVarintPerpetual(dAtA, i, uint64(len(m.Ticker)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintPerpetual(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MarketPremiums) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MarketPremiums) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MarketPremiums) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Premiums) > 0 {
		dAtA1 := make([]byte, len(m.Premiums)*5)
		var j2 int
		for _, num := range m.Premiums {
			x3 := (uint32(num) << 1) ^ uint32((num >> 31))
			for x3 >= 1<<7 {
				dAtA1[j2] = uint8(uint64(x3)&0x7f | 0x80)
				j2++
				x3 >>= 7
			}
			dAtA1[j2] = uint8(x3)
			j2++
		}
		i -= j2
		copy(dAtA[i:], dAtA1[:j2])
		i = encodeVarintPerpetual(dAtA, i, uint64(j2))
		i--
		dAtA[i] = 0x12
	}
	if m.PerpetualId != 0 {
		i = encodeVarintPerpetual(dAtA, i, uint64(m.PerpetualId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PremiumStore) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PremiumStore) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PremiumStore) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NumPremiums != 0 {
		i = encodeVarintPerpetual(dAtA, i, uint64(m.NumPremiums))
		i--
		dAtA[i] = 0x10
	}
	if len(m.AllMarketPremiums) > 0 {
		for iNdEx := len(m.AllMarketPremiums) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AllMarketPremiums[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPerpetual(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *LiquidityTier) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LiquidityTier) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LiquidityTier) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BasePositionNotional != 0 {
		i = encodeVarintPerpetual(dAtA, i, uint64(m.BasePositionNotional))
		i--
		dAtA[i] = 0x28
	}
	if m.MaintenanceFractionPpm != 0 {
		i = encodeVarintPerpetual(dAtA, i, uint64(m.MaintenanceFractionPpm))
		i--
		dAtA[i] = 0x20
	}
	if m.InitialMarginPpm != 0 {
		i = encodeVarintPerpetual(dAtA, i, uint64(m.InitialMarginPpm))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPerpetual(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintPerpetual(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintPerpetual(dAtA []byte, offset int, v uint64) int {
	offset -= sovPerpetual(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Perpetual) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovPerpetual(uint64(m.Id))
	}
	l = len(m.Ticker)
	if l > 0 {
		n += 1 + l + sovPerpetual(uint64(l))
	}
	if m.MarketId != 0 {
		n += 1 + sovPerpetual(uint64(m.MarketId))
	}
	if m.AtomicResolution != 0 {
		n += 1 + sozPerpetual(uint64(m.AtomicResolution))
	}
	if m.DefaultFundingPpm != 0 {
		n += 1 + sozPerpetual(uint64(m.DefaultFundingPpm))
	}
	if m.LiquidityTier != 0 {
		n += 1 + sovPerpetual(uint64(m.LiquidityTier))
	}
	l = m.FundingIndex.Size()
	n += 1 + l + sovPerpetual(uint64(l))
	if m.OpenInterest != 0 {
		n += 1 + sovPerpetual(uint64(m.OpenInterest))
	}
	return n
}

func (m *MarketPremiums) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PerpetualId != 0 {
		n += 1 + sovPerpetual(uint64(m.PerpetualId))
	}
	if len(m.Premiums) > 0 {
		l = 0
		for _, e := range m.Premiums {
			l += sozPerpetual(uint64(e))
		}
		n += 1 + sovPerpetual(uint64(l)) + l
	}
	return n
}

func (m *PremiumStore) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.AllMarketPremiums) > 0 {
		for _, e := range m.AllMarketPremiums {
			l = e.Size()
			n += 1 + l + sovPerpetual(uint64(l))
		}
	}
	if m.NumPremiums != 0 {
		n += 1 + sovPerpetual(uint64(m.NumPremiums))
	}
	return n
}

func (m *LiquidityTier) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovPerpetual(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPerpetual(uint64(l))
	}
	if m.InitialMarginPpm != 0 {
		n += 1 + sovPerpetual(uint64(m.InitialMarginPpm))
	}
	if m.MaintenanceFractionPpm != 0 {
		n += 1 + sovPerpetual(uint64(m.MaintenanceFractionPpm))
	}
	if m.BasePositionNotional != 0 {
		n += 1 + sovPerpetual(uint64(m.BasePositionNotional))
	}
	return n
}

func sovPerpetual(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozPerpetual(x uint64) (n int) {
	return sovPerpetual(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Perpetual) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPerpetual
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Perpetual: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Perpetual: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPerpetual
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ticker", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPerpetual
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPerpetual
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPerpetual
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ticker = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			m.MarketId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPerpetual
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MarketId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AtomicResolution", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPerpetual
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.AtomicResolution = v
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultFundingPpm", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPerpetual
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.DefaultFundingPpm = v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiquidityTier", wireType)
			}
			m.LiquidityTier = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPerpetual
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LiquidityTier |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FundingIndex", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPerpetual
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPerpetual
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPerpetual
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FundingIndex.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenInterest", wireType)
			}
			m.OpenInterest = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPerpetual
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OpenInterest |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPerpetual(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPerpetual
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MarketPremiums) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPerpetual
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MarketPremiums: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MarketPremiums: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PerpetualId", wireType)
			}
			m.PerpetualId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPerpetual
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PerpetualId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPerpetual
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
				m.Premiums = append(m.Premiums, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPerpetual
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPerpetual
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPerpetual
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Premiums) == 0 {
					m.Premiums = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPerpetual
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
					m.Premiums = append(m.Premiums, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Premiums", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPerpetual(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPerpetual
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PremiumStore) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPerpetual
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PremiumStore: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PremiumStore: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllMarketPremiums", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPerpetual
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPerpetual
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPerpetual
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllMarketPremiums = append(m.AllMarketPremiums, MarketPremiums{})
			if err := m.AllMarketPremiums[len(m.AllMarketPremiums)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumPremiums", wireType)
			}
			m.NumPremiums = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPerpetual
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumPremiums |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPerpetual(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPerpetual
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LiquidityTier) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPerpetual
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LiquidityTier: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LiquidityTier: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPerpetual
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPerpetual
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPerpetual
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPerpetual
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitialMarginPpm", wireType)
			}
			m.InitialMarginPpm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPerpetual
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InitialMarginPpm |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaintenanceFractionPpm", wireType)
			}
			m.MaintenanceFractionPpm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPerpetual
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaintenanceFractionPpm |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BasePositionNotional", wireType)
			}
			m.BasePositionNotional = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPerpetual
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BasePositionNotional |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPerpetual(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPerpetual
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPerpetual(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPerpetual
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPerpetual
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPerpetual
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthPerpetual
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupPerpetual
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthPerpetual
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthPerpetual        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPerpetual          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupPerpetual = fmt.Errorf("proto: unexpected end of group")
)
