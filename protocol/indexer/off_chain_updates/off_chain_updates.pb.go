// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: dydxprotocol/indexer/off_chain_updates/off_chain_updates.proto

package off_chain_updates

import (
	fmt "fmt"
	proto "github.com/cosmos/gogoproto/proto"
	types "github.com/dydxprotocol/v4/x/clob/types"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// OrderPlacementStatus is an enum for the resulting status after an order is
// placed.
type OrderPlace_OrderPlacementStatus int32

const (
	// Default value, this is invalid and unused.
	OrderPlace_ORDER_PLACEMENT_STATUS_UNSPECIFIED OrderPlace_OrderPlacementStatus = 0
	// A best effort opened order is one that has only been confirmed to be
	// placed on the V4 node sending the off-chain update message.
	// The cases where this happens includes:
	// - The V4 node places an order in it's in-memory orderbook during the
	//   CheckTx flow.
	// A best effort placed order may not have been placed on other V4
	// nodes including other V4 validator nodes and may still be excluded in
	// future order matches.
	OrderPlace_ORDER_PLACEMENT_STATUS_BEST_EFFORT_OPENED OrderPlace_OrderPlacementStatus = 1
	// An opened order is one that is confirmed to be placed on all V4 nodes
	// (discounting dishonest V4 nodes) and will be included in any future
	// order matches.
	// This status is used internally by the indexer and will not be sent
	// out by protocol.
	OrderPlace_ORDER_PLACEMENT_STATUS_OPENED OrderPlace_OrderPlacementStatus = 2
)

var OrderPlace_OrderPlacementStatus_name = map[int32]string{
	0: "ORDER_PLACEMENT_STATUS_UNSPECIFIED",
	1: "ORDER_PLACEMENT_STATUS_BEST_EFFORT_OPENED",
	2: "ORDER_PLACEMENT_STATUS_OPENED",
}

var OrderPlace_OrderPlacementStatus_value = map[string]int32{
	"ORDER_PLACEMENT_STATUS_UNSPECIFIED":        0,
	"ORDER_PLACEMENT_STATUS_BEST_EFFORT_OPENED": 1,
	"ORDER_PLACEMENT_STATUS_OPENED":             2,
}

func (x OrderPlace_OrderPlacementStatus) String() string {
	return proto.EnumName(OrderPlace_OrderPlacementStatus_name, int32(x))
}

func (OrderPlace_OrderPlacementStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a3058c1b66f59e98, []int{0, 0}
}

// OrderRemovalReason is an enum of all the reasons an order was removed.
type OrderRemove_OrderRemovalReason int32

const (
	// Default value, this is invalid and unused.
	OrderRemove_ORDER_REMOVAL_REASON_UNSPECIFIED OrderRemove_OrderRemovalReason = 0
	// The order was removed due to being expired.
	OrderRemove_ORDER_REMOVAL_REASON_EXPIRED OrderRemove_OrderRemovalReason = 1
	// The order was removed due to being canceled by a user.
	OrderRemove_ORDER_REMOVAL_REASON_USER_CANCELED OrderRemove_OrderRemovalReason = 2
	// The order was removed due to being undercollateralized.
	OrderRemove_ORDER_REMOVAL_REASON_UNDERCOLLATERALIZED OrderRemove_OrderRemovalReason = 3
	// The order caused an internal error during order placement and was
	// removed.
	OrderRemove_ORDER_REMOVAL_REASON_INTERNAL_ERROR OrderRemove_OrderRemovalReason = 4
	// The order would have matched against another order placed by the same
	// subaccount and was removed.
	OrderRemove_ORDER_REMOVAL_REASON_SELF_TRADE_ERROR OrderRemove_OrderRemovalReason = 5
	// The order would have matched against maker orders on the orderbook
	// despite being a post-only order and was removed.
	OrderRemove_ORDER_REMOVAL_REASON_POST_ONLY_WOULD_CROSS_MAKER_ORDER OrderRemove_OrderRemovalReason = 6
	// The order was an ICO order and would have been placed on the orderbook as
	// resting liquidity and was removed.
	OrderRemove_ORDER_REMOVAL_REASON_IMMEDIATE_OR_CANCEL_WOULD_REST_ON_BOOK OrderRemove_OrderRemovalReason = 7
	// The order was a fill-or-kill order that could not be fully filled and was
	// removed.
	OrderRemove_ORDER_REMOVAL_REASON_FOK_ORDER_COULD_NOT_BE_FULLY_FULLED OrderRemove_OrderRemovalReason = 8
	// The order was a reduce-only order that was removed due to either:
	// - being a taker order and fully-filling the order would flip the side of
	//    the subaccount's position, in this case the remaining size of the
	//    order is removed
	// - being a maker order resting on the book and being removed when either
	//    the subaccount's position is closed or flipped sides
	OrderRemove_ORDER_REMOVAL_REASON_REDUCE_ONLY_RESIZE OrderRemove_OrderRemovalReason = 9
	// The order should be expired, according to the Indexer's cached data, but
	// the Indexer has yet to receive a message to remove the order. In order to
	// keep the data cached by the Indexer up-to-date and accurate, clear out
	// the data if it's expired by sending an order removal with this reason.
	// Protocol should never send this reason to Indexer.
	OrderRemove_ORDER_REMOVAL_REASON_INDEXER_EXPIRED OrderRemove_OrderRemovalReason = 10
)

var OrderRemove_OrderRemovalReason_name = map[int32]string{
	0:  "ORDER_REMOVAL_REASON_UNSPECIFIED",
	1:  "ORDER_REMOVAL_REASON_EXPIRED",
	2:  "ORDER_REMOVAL_REASON_USER_CANCELED",
	3:  "ORDER_REMOVAL_REASON_UNDERCOLLATERALIZED",
	4:  "ORDER_REMOVAL_REASON_INTERNAL_ERROR",
	5:  "ORDER_REMOVAL_REASON_SELF_TRADE_ERROR",
	6:  "ORDER_REMOVAL_REASON_POST_ONLY_WOULD_CROSS_MAKER_ORDER",
	7:  "ORDER_REMOVAL_REASON_IMMEDIATE_OR_CANCEL_WOULD_REST_ON_BOOK",
	8:  "ORDER_REMOVAL_REASON_FOK_ORDER_COULD_NOT_BE_FULLY_FULLED",
	9:  "ORDER_REMOVAL_REASON_REDUCE_ONLY_RESIZE",
	10: "ORDER_REMOVAL_REASON_INDEXER_EXPIRED",
}

var OrderRemove_OrderRemovalReason_value = map[string]int32{
	"ORDER_REMOVAL_REASON_UNSPECIFIED":                            0,
	"ORDER_REMOVAL_REASON_EXPIRED":                                1,
	"ORDER_REMOVAL_REASON_USER_CANCELED":                          2,
	"ORDER_REMOVAL_REASON_UNDERCOLLATERALIZED":                    3,
	"ORDER_REMOVAL_REASON_INTERNAL_ERROR":                         4,
	"ORDER_REMOVAL_REASON_SELF_TRADE_ERROR":                       5,
	"ORDER_REMOVAL_REASON_POST_ONLY_WOULD_CROSS_MAKER_ORDER":      6,
	"ORDER_REMOVAL_REASON_IMMEDIATE_OR_CANCEL_WOULD_REST_ON_BOOK": 7,
	"ORDER_REMOVAL_REASON_FOK_ORDER_COULD_NOT_BE_FULLY_FULLED":    8,
	"ORDER_REMOVAL_REASON_REDUCE_ONLY_RESIZE":                     9,
	"ORDER_REMOVAL_REASON_INDEXER_EXPIRED":                        10,
}

func (x OrderRemove_OrderRemovalReason) String() string {
	return proto.EnumName(OrderRemove_OrderRemovalReason_name, int32(x))
}

func (OrderRemove_OrderRemovalReason) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a3058c1b66f59e98, []int{1, 0}
}

// OrderRemovalStatus is an enum for the resulting status after an order is
// removed.
type OrderRemove_OrderRemovalStatus int32

const (
	// Default value, this is invalid and unused.
	OrderRemove_ORDER_REMOVAL_STATUS_UNSPECIFIED OrderRemove_OrderRemovalStatus = 0
	// A best effort canceled order is one that has only been confirmed to be
	// removed on the V4 node sending the off-chain update message.
	// The cases where this happens includes:
	// - the order was removed due to the V4 node receiving a CancelOrder
	//   transaction for the order.
	// - the order was removed due to being undercollateralized during
	//   optimistic matching.
	// A best effort canceled order may not have been removed on other V4
	// nodes including other V4 validator nodes and may still be included in
	// future order matches.
	OrderRemove_ORDER_REMOVAL_STATUS_BEST_EFFORT_CANCELED OrderRemove_OrderRemovalStatus = 1
	// A canceled order is one that is confirmed to be removed on all V4 nodes
	// (discounting dishonest V4 nodes) and will not be included in any future
	// order matches.
	// The cases where this happens includes:
	// - the order is expired.
	OrderRemove_ORDER_REMOVAL_STATUS_CANCELED OrderRemove_OrderRemovalStatus = 2
)

var OrderRemove_OrderRemovalStatus_name = map[int32]string{
	0: "ORDER_REMOVAL_STATUS_UNSPECIFIED",
	1: "ORDER_REMOVAL_STATUS_BEST_EFFORT_CANCELED",
	2: "ORDER_REMOVAL_STATUS_CANCELED",
}

var OrderRemove_OrderRemovalStatus_value = map[string]int32{
	"ORDER_REMOVAL_STATUS_UNSPECIFIED":          0,
	"ORDER_REMOVAL_STATUS_BEST_EFFORT_CANCELED": 1,
	"ORDER_REMOVAL_STATUS_CANCELED":             2,
}

func (x OrderRemove_OrderRemovalStatus) String() string {
	return proto.EnumName(OrderRemove_OrderRemovalStatus_name, int32(x))
}

func (OrderRemove_OrderRemovalStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a3058c1b66f59e98, []int{1, 1}
}

// OrderPlace messages contain the order placed/replaced.
type OrderPlace struct {
	Order           *types.Order                    `protobuf:"bytes,1,opt,name=order,proto3" json:"order,omitempty"`
	PlacementStatus OrderPlace_OrderPlacementStatus `protobuf:"varint,2,opt,name=placement_status,json=placementStatus,proto3,enum=dydxprotocol.indexer.off_chain_updates.OrderPlace_OrderPlacementStatus" json:"placement_status,omitempty"`
}

func (m *OrderPlace) Reset()         { *m = OrderPlace{} }
func (m *OrderPlace) String() string { return proto.CompactTextString(m) }
func (*OrderPlace) ProtoMessage()    {}
func (*OrderPlace) Descriptor() ([]byte, []int) {
	return fileDescriptor_a3058c1b66f59e98, []int{0}
}
func (m *OrderPlace) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OrderPlace) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OrderPlace.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OrderPlace) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OrderPlace.Merge(m, src)
}
func (m *OrderPlace) XXX_Size() int {
	return m.Size()
}
func (m *OrderPlace) XXX_DiscardUnknown() {
	xxx_messageInfo_OrderPlace.DiscardUnknown(m)
}

var xxx_messageInfo_OrderPlace proto.InternalMessageInfo

func (m *OrderPlace) GetOrder() *types.Order {
	if m != nil {
		return m.Order
	}
	return nil
}

func (m *OrderPlace) GetPlacementStatus() OrderPlace_OrderPlacementStatus {
	if m != nil {
		return m.PlacementStatus
	}
	return OrderPlace_ORDER_PLACEMENT_STATUS_UNSPECIFIED
}

// OrderRemove messages contain the id of the order removed, the reason for the
// removal and the resulting status from the removal.
type OrderRemove struct {
	RemovedOrderId *types.OrderId                 `protobuf:"bytes,1,opt,name=removed_order_id,json=removedOrderId,proto3" json:"removed_order_id,omitempty"`
	Reason         OrderRemove_OrderRemovalReason `protobuf:"varint,2,opt,name=reason,proto3,enum=dydxprotocol.indexer.off_chain_updates.OrderRemove_OrderRemovalReason" json:"reason,omitempty"`
	RemovalStatus  OrderRemove_OrderRemovalStatus `protobuf:"varint,3,opt,name=removal_status,json=removalStatus,proto3,enum=dydxprotocol.indexer.off_chain_updates.OrderRemove_OrderRemovalStatus" json:"removal_status,omitempty"`
}

func (m *OrderRemove) Reset()         { *m = OrderRemove{} }
func (m *OrderRemove) String() string { return proto.CompactTextString(m) }
func (*OrderRemove) ProtoMessage()    {}
func (*OrderRemove) Descriptor() ([]byte, []int) {
	return fileDescriptor_a3058c1b66f59e98, []int{1}
}
func (m *OrderRemove) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OrderRemove) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OrderRemove.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OrderRemove) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OrderRemove.Merge(m, src)
}
func (m *OrderRemove) XXX_Size() int {
	return m.Size()
}
func (m *OrderRemove) XXX_DiscardUnknown() {
	xxx_messageInfo_OrderRemove.DiscardUnknown(m)
}

var xxx_messageInfo_OrderRemove proto.InternalMessageInfo

func (m *OrderRemove) GetRemovedOrderId() *types.OrderId {
	if m != nil {
		return m.RemovedOrderId
	}
	return nil
}

func (m *OrderRemove) GetReason() OrderRemove_OrderRemovalReason {
	if m != nil {
		return m.Reason
	}
	return OrderRemove_ORDER_REMOVAL_REASON_UNSPECIFIED
}

func (m *OrderRemove) GetRemovalStatus() OrderRemove_OrderRemovalStatus {
	if m != nil {
		return m.RemovalStatus
	}
	return OrderRemove_ORDER_REMOVAL_STATUS_UNSPECIFIED
}

// OrderUpdate messages contain the id of the order being updated, and the
// updated total filled quantums of the order.
type OrderUpdate struct {
	OrderId             *types.OrderId `protobuf:"bytes,1,opt,name=order_id,json=orderId,proto3" json:"order_id,omitempty"`
	TotalFilledQuantums uint64         `protobuf:"varint,2,opt,name=total_filled_quantums,json=totalFilledQuantums,proto3" json:"total_filled_quantums,omitempty"`
}

func (m *OrderUpdate) Reset()         { *m = OrderUpdate{} }
func (m *OrderUpdate) String() string { return proto.CompactTextString(m) }
func (*OrderUpdate) ProtoMessage()    {}
func (*OrderUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptor_a3058c1b66f59e98, []int{2}
}
func (m *OrderUpdate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OrderUpdate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OrderUpdate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OrderUpdate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OrderUpdate.Merge(m, src)
}
func (m *OrderUpdate) XXX_Size() int {
	return m.Size()
}
func (m *OrderUpdate) XXX_DiscardUnknown() {
	xxx_messageInfo_OrderUpdate.DiscardUnknown(m)
}

var xxx_messageInfo_OrderUpdate proto.InternalMessageInfo

func (m *OrderUpdate) GetOrderId() *types.OrderId {
	if m != nil {
		return m.OrderId
	}
	return nil
}

func (m *OrderUpdate) GetTotalFilledQuantums() uint64 {
	if m != nil {
		return m.TotalFilledQuantums
	}
	return 0
}

// An OffChainUpdate message is the message type which will be sent on Kafka to
// the Indexer.
type OffChainUpdate struct {
	// Contains one of an OrderPlace, OrderRemove, and OrderUpdate message.
	//
	// Types that are valid to be assigned to UpdateMessage:
	//	*OffChainUpdate_OrderPlace
	//	*OffChainUpdate_OrderRemove
	//	*OffChainUpdate_OrderUpdate
	UpdateMessage isOffChainUpdate_UpdateMessage `protobuf_oneof:"update_message"`
}

func (m *OffChainUpdate) Reset()         { *m = OffChainUpdate{} }
func (m *OffChainUpdate) String() string { return proto.CompactTextString(m) }
func (*OffChainUpdate) ProtoMessage()    {}
func (*OffChainUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptor_a3058c1b66f59e98, []int{3}
}
func (m *OffChainUpdate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OffChainUpdate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OffChainUpdate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OffChainUpdate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OffChainUpdate.Merge(m, src)
}
func (m *OffChainUpdate) XXX_Size() int {
	return m.Size()
}
func (m *OffChainUpdate) XXX_DiscardUnknown() {
	xxx_messageInfo_OffChainUpdate.DiscardUnknown(m)
}

var xxx_messageInfo_OffChainUpdate proto.InternalMessageInfo

type isOffChainUpdate_UpdateMessage interface {
	isOffChainUpdate_UpdateMessage()
	MarshalTo([]byte) (int, error)
	Size() int
}

type OffChainUpdate_OrderPlace struct {
	OrderPlace *OrderPlace `protobuf:"bytes,1,opt,name=order_place,json=orderPlace,proto3,oneof" json:"order_place,omitempty"`
}
type OffChainUpdate_OrderRemove struct {
	OrderRemove *OrderRemove `protobuf:"bytes,2,opt,name=order_remove,json=orderRemove,proto3,oneof" json:"order_remove,omitempty"`
}
type OffChainUpdate_OrderUpdate struct {
	OrderUpdate *OrderUpdate `protobuf:"bytes,3,opt,name=order_update,json=orderUpdate,proto3,oneof" json:"order_update,omitempty"`
}

func (*OffChainUpdate_OrderPlace) isOffChainUpdate_UpdateMessage()  {}
func (*OffChainUpdate_OrderRemove) isOffChainUpdate_UpdateMessage() {}
func (*OffChainUpdate_OrderUpdate) isOffChainUpdate_UpdateMessage() {}

func (m *OffChainUpdate) GetUpdateMessage() isOffChainUpdate_UpdateMessage {
	if m != nil {
		return m.UpdateMessage
	}
	return nil
}

func (m *OffChainUpdate) GetOrderPlace() *OrderPlace {
	if x, ok := m.GetUpdateMessage().(*OffChainUpdate_OrderPlace); ok {
		return x.OrderPlace
	}
	return nil
}

func (m *OffChainUpdate) GetOrderRemove() *OrderRemove {
	if x, ok := m.GetUpdateMessage().(*OffChainUpdate_OrderRemove); ok {
		return x.OrderRemove
	}
	return nil
}

func (m *OffChainUpdate) GetOrderUpdate() *OrderUpdate {
	if x, ok := m.GetUpdateMessage().(*OffChainUpdate_OrderUpdate); ok {
		return x.OrderUpdate
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*OffChainUpdate) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*OffChainUpdate_OrderPlace)(nil),
		(*OffChainUpdate_OrderRemove)(nil),
		(*OffChainUpdate_OrderUpdate)(nil),
	}
}

func init() {
	proto.RegisterEnum("dydxprotocol.indexer.off_chain_updates.OrderPlace_OrderPlacementStatus", OrderPlace_OrderPlacementStatus_name, OrderPlace_OrderPlacementStatus_value)
	proto.RegisterEnum("dydxprotocol.indexer.off_chain_updates.OrderRemove_OrderRemovalReason", OrderRemove_OrderRemovalReason_name, OrderRemove_OrderRemovalReason_value)
	proto.RegisterEnum("dydxprotocol.indexer.off_chain_updates.OrderRemove_OrderRemovalStatus", OrderRemove_OrderRemovalStatus_name, OrderRemove_OrderRemovalStatus_value)
	proto.RegisterType((*OrderPlace)(nil), "dydxprotocol.indexer.off_chain_updates.OrderPlace")
	proto.RegisterType((*OrderRemove)(nil), "dydxprotocol.indexer.off_chain_updates.OrderRemove")
	proto.RegisterType((*OrderUpdate)(nil), "dydxprotocol.indexer.off_chain_updates.OrderUpdate")
	proto.RegisterType((*OffChainUpdate)(nil), "dydxprotocol.indexer.off_chain_updates.OffChainUpdate")
}

func init() {
	proto.RegisterFile("dydxprotocol/indexer/off_chain_updates/off_chain_updates.proto", fileDescriptor_a3058c1b66f59e98)
}

var fileDescriptor_a3058c1b66f59e98 = []byte{
	// 788 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x55, 0x4f, 0x8f, 0xdb, 0x44,
	0x14, 0x8f, 0xb7, 0xdb, 0xdd, 0xf2, 0x16, 0x16, 0x6b, 0x00, 0x69, 0x55, 0xd1, 0x68, 0x31, 0xa5,
	0xdd, 0x0a, 0xf0, 0x4a, 0x69, 0x41, 0x08, 0x10, 0xc8, 0xb1, 0x9f, 0xa9, 0xb5, 0x8e, 0x27, 0x8c,
	0x1d, 0xd8, 0xee, 0x81, 0x91, 0x37, 0x76, 0xda, 0x48, 0x4e, 0x1c, 0x1c, 0xa7, 0x5a, 0xbe, 0x03,
	0x87, 0x1e, 0xf9, 0x12, 0x7c, 0x0a, 0x2e, 0x1c, 0x38, 0xf4, 0xc8, 0x11, 0xed, 0x7e, 0x11, 0x94,
	0x99, 0x69, 0x36, 0x7f, 0x1c, 0x44, 0x10, 0x17, 0x6b, 0xc6, 0xf3, 0x7b, 0xbf, 0xdf, 0xf3, 0x7b,
	0xf3, 0x7b, 0x86, 0xaf, 0x92, 0x9f, 0x92, 0x8b, 0x51, 0x91, 0x97, 0x79, 0x37, 0xcf, 0x8e, 0xfb,
	0xc3, 0x24, 0xbd, 0x48, 0x8b, 0xe3, 0xbc, 0xd7, 0xe3, 0xdd, 0x67, 0x71, 0x7f, 0xc8, 0x27, 0xa3,
	0x24, 0x2e, 0xd3, 0xf1, 0xea, 0x1b, 0x53, 0x04, 0x91, 0x7b, 0xf3, 0xf1, 0xa6, 0x8a, 0x37, 0x57,
	0xd0, 0xb7, 0xef, 0x2c, 0xe8, 0x74, 0xb3, 0xfc, 0xfc, 0x38, 0x2f, 0x92, 0xb4, 0x90, 0x34, 0xc6,
	0x6f, 0x5b, 0x00, 0x74, 0xba, 0x6f, 0x67, 0x71, 0x37, 0x25, 0x26, 0xdc, 0x14, 0xa7, 0x07, 0xda,
	0xa1, 0x76, 0xb4, 0xd7, 0x38, 0x30, 0x17, 0x54, 0xa6, 0xd1, 0xa6, 0x40, 0x33, 0x09, 0x23, 0x05,
	0xe8, 0xa3, 0x69, 0xe0, 0x20, 0x1d, 0x96, 0x7c, 0x5c, 0xc6, 0xe5, 0x64, 0x7c, 0xb0, 0x75, 0xa8,
	0x1d, 0xed, 0x37, 0xbe, 0x31, 0xff, 0x5d, 0x82, 0xe6, 0xb5, 0xfa, 0xdc, 0x72, 0xca, 0x17, 0x0a,
	0x3a, 0xf6, 0xe6, 0x68, 0xf1, 0x85, 0xf1, 0x42, 0x83, 0xb7, 0xab, 0x90, 0xe4, 0x1e, 0x18, 0x94,
	0x39, 0xc8, 0x78, 0xdb, 0xb7, 0x6c, 0x6c, 0x61, 0x10, 0xf1, 0x30, 0xb2, 0xa2, 0x4e, 0xc8, 0x3b,
	0x41, 0xd8, 0x46, 0xdb, 0x73, 0x3d, 0x74, 0xf4, 0x1a, 0xf9, 0x18, 0x1e, 0xac, 0xc1, 0x35, 0x31,
	0x8c, 0x38, 0xba, 0x2e, 0x65, 0x11, 0xa7, 0x6d, 0x0c, 0xd0, 0xd1, 0x35, 0xf2, 0x1e, 0xdc, 0x59,
	0x03, 0x57, 0x90, 0x2d, 0xe3, 0x8f, 0x5d, 0xd8, 0x93, 0x75, 0x49, 0x07, 0xf9, 0xf3, 0x94, 0x38,
	0xa0, 0x17, 0x62, 0x95, 0x70, 0x51, 0x27, 0xde, 0x4f, 0x54, 0x45, 0x6f, 0xaf, 0xab, 0xa8, 0x97,
	0xb0, 0x7d, 0x15, 0xa3, 0xf6, 0xe4, 0x07, 0xd8, 0x29, 0xd2, 0x78, 0x9c, 0x0f, 0x55, 0x49, 0xdd,
	0x8d, 0x4a, 0x2a, 0x53, 0x99, 0x5b, 0xc7, 0x19, 0x13, 0x6c, 0x4c, 0xb1, 0x92, 0x01, 0x48, 0xc5,
	0x38, 0x7b, 0xd5, 0xba, 0x1b, 0xff, 0x8f, 0x8e, 0xea, 0xdc, 0x1b, 0xc5, 0xfc, 0xd6, 0xf8, 0x65,
	0x1b, 0xc8, 0x6a, 0x36, 0xe4, 0x2e, 0x1c, 0xca, 0xf2, 0x32, 0x6c, 0xd1, 0xef, 0x2c, 0x9f, 0x33,
	0xb4, 0x42, 0x1a, 0x2c, 0xf5, 0xec, 0x10, 0xde, 0xad, 0x44, 0xe1, 0x69, 0xdb, 0x63, 0xa2, 0x4d,
	0xb3, 0xee, 0x2f, 0xf3, 0x84, 0xc8, 0xb8, 0x6d, 0x05, 0x36, 0xfa, 0xd3, 0x5e, 0x91, 0x8f, 0xe0,
	0x68, 0x8d, 0x9e, 0x83, 0xcc, 0xa6, 0xbe, 0x6f, 0x45, 0xc8, 0x2c, 0xdf, 0x3b, 0x43, 0x47, 0xbf,
	0x41, 0xee, 0xc3, 0xfb, 0x95, 0x68, 0x2f, 0x88, 0x90, 0x05, 0x96, 0xcf, 0x91, 0x31, 0xca, 0xf4,
	0x6d, 0xf2, 0x00, 0x3e, 0xa8, 0x04, 0x86, 0xe8, 0xbb, 0x3c, 0x62, 0x96, 0x83, 0x0a, 0x7a, 0x93,
	0x7c, 0x0e, 0x9f, 0x56, 0x42, 0xdb, 0x34, 0x8c, 0x38, 0x0d, 0xfc, 0x27, 0xfc, 0x7b, 0xda, 0xf1,
	0x1d, 0x6e, 0x33, 0x1a, 0x86, 0xbc, 0x65, 0x9d, 0x20, 0xe3, 0x22, 0x40, 0xdf, 0x21, 0x5f, 0xc3,
	0x17, 0xd5, 0xf9, 0xb4, 0x5a, 0xe8, 0x78, 0x56, 0x84, 0x9c, 0xbe, 0xfa, 0x5a, 0xc5, 0xc2, 0x50,
	0xb0, 0xf2, 0x26, 0xa5, 0x27, 0xfa, 0x2e, 0xf9, 0x12, 0x3e, 0xab, 0x24, 0x70, 0xe9, 0x89, 0x14,
	0xe1, 0xb6, 0x08, 0x0b, 0x68, 0xc4, 0x9b, 0xc8, 0xdd, 0x8e, 0xef, 0x3f, 0x11, 0x4f, 0x74, 0xf4,
	0x5b, 0xe4, 0x43, 0xb8, 0x5f, 0x19, 0xcd, 0xd0, 0xe9, 0xd8, 0x28, 0x93, 0x67, 0x18, 0x7a, 0x67,
	0xa8, 0xbf, 0x46, 0x8e, 0xe0, 0xee, 0x9a, 0xda, 0x39, 0x78, 0x8a, 0x6c, 0xd6, 0x3b, 0x30, 0x7e,
	0xd6, 0x16, 0xaf, 0x86, 0x32, 0xf4, 0xca, 0xd5, 0xf8, 0x67, 0x3b, 0x2f, 0xa1, 0xe6, 0xcd, 0x3c,
	0xeb, 0xff, 0x9c, 0x9d, 0x97, 0xe0, 0xd7, 0x57, 0xc4, 0xb8, 0x50, 0x6e, 0xee, 0x88, 0x7b, 0x4e,
	0x3e, 0x81, 0x5b, 0x1b, 0xb8, 0x78, 0x37, 0x57, 0xf6, 0x6d, 0xc0, 0x3b, 0x65, 0x5e, 0xc6, 0x19,
	0xef, 0xf5, 0xb3, 0x2c, 0x4d, 0xf8, 0x8f, 0x93, 0x78, 0x58, 0x4e, 0x06, 0x72, 0x40, 0x6e, 0xb3,
	0xb7, 0xc4, 0xa1, 0x2b, 0xce, 0xbe, 0x55, 0x47, 0xc6, 0xaf, 0x5b, 0xb0, 0x4f, 0x7b, 0x3d, 0x7b,
	0x6a, 0x33, 0xa5, 0xde, 0x81, 0x3d, 0xa9, 0x2e, 0xe6, 0xa0, 0x4a, 0xa0, 0xb1, 0xf9, 0x74, 0x7d,
	0x5c, 0x63, 0x90, 0x5f, 0x4f, 0xfa, 0x53, 0x78, 0x5d, 0xd2, 0xca, 0xa1, 0x23, 0x92, 0xda, 0x6b,
	0x3c, 0xfc, 0x0f, 0xd6, 0x7f, 0x5c, 0x63, 0x32, 0x43, 0x35, 0xfc, 0x66, 0xcc, 0x12, 0x2b, 0x86,
	0xca, 0xa6, 0xcc, 0xf2, 0xdb, 0x67, 0xcc, 0x72, 0xdb, 0xd4, 0x61, 0x5f, 0xa2, 0xf8, 0x20, 0x1d,
	0x8f, 0xe3, 0xa7, 0x69, 0x33, 0xf8, 0xfd, 0xb2, 0xae, 0xbd, 0xbc, 0xac, 0x6b, 0x7f, 0x5d, 0xd6,
	0xb5, 0x17, 0x57, 0xf5, 0xda, 0xcb, 0xab, 0x7a, 0xed, 0xcf, 0xab, 0x7a, 0xed, 0xec, 0xd1, 0xd3,
	0x7e, 0xf9, 0x6c, 0x72, 0x6e, 0x76, 0xf3, 0xc1, 0xf1, 0xc2, 0x2f, 0xf0, 0xf9, 0xa3, 0xf5, 0x7f,
	0xdb, 0xf3, 0x1d, 0x01, 0x7b, 0xf8, 0x77, 0x00, 0x00, 0x00, 0xff, 0xff, 0xae, 0xb1, 0xf3, 0x58,
	0x9e, 0x07, 0x00, 0x00,
}

func (m *OrderPlace) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrderPlace) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OrderPlace) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PlacementStatus != 0 {
		i = encodeVarintOffChainUpdates(dAtA, i, uint64(m.PlacementStatus))
		i--
		dAtA[i] = 0x10
	}
	if m.Order != nil {
		{
			size, err := m.Order.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOffChainUpdates(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OrderRemove) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrderRemove) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OrderRemove) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RemovalStatus != 0 {
		i = encodeVarintOffChainUpdates(dAtA, i, uint64(m.RemovalStatus))
		i--
		dAtA[i] = 0x18
	}
	if m.Reason != 0 {
		i = encodeVarintOffChainUpdates(dAtA, i, uint64(m.Reason))
		i--
		dAtA[i] = 0x10
	}
	if m.RemovedOrderId != nil {
		{
			size, err := m.RemovedOrderId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOffChainUpdates(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OrderUpdate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrderUpdate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OrderUpdate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TotalFilledQuantums != 0 {
		i = encodeVarintOffChainUpdates(dAtA, i, uint64(m.TotalFilledQuantums))
		i--
		dAtA[i] = 0x10
	}
	if m.OrderId != nil {
		{
			size, err := m.OrderId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOffChainUpdates(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OffChainUpdate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OffChainUpdate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OffChainUpdate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UpdateMessage != nil {
		{
			size := m.UpdateMessage.Size()
			i -= size
			if _, err := m.UpdateMessage.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *OffChainUpdate_OrderPlace) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OffChainUpdate_OrderPlace) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.OrderPlace != nil {
		{
			size, err := m.OrderPlace.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOffChainUpdates(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *OffChainUpdate_OrderRemove) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OffChainUpdate_OrderRemove) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.OrderRemove != nil {
		{
			size, err := m.OrderRemove.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOffChainUpdates(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *OffChainUpdate_OrderUpdate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OffChainUpdate_OrderUpdate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.OrderUpdate != nil {
		{
			size, err := m.OrderUpdate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintOffChainUpdates(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func encodeVarintOffChainUpdates(dAtA []byte, offset int, v uint64) int {
	offset -= sovOffChainUpdates(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *OrderPlace) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Order != nil {
		l = m.Order.Size()
		n += 1 + l + sovOffChainUpdates(uint64(l))
	}
	if m.PlacementStatus != 0 {
		n += 1 + sovOffChainUpdates(uint64(m.PlacementStatus))
	}
	return n
}

func (m *OrderRemove) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RemovedOrderId != nil {
		l = m.RemovedOrderId.Size()
		n += 1 + l + sovOffChainUpdates(uint64(l))
	}
	if m.Reason != 0 {
		n += 1 + sovOffChainUpdates(uint64(m.Reason))
	}
	if m.RemovalStatus != 0 {
		n += 1 + sovOffChainUpdates(uint64(m.RemovalStatus))
	}
	return n
}

func (m *OrderUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OrderId != nil {
		l = m.OrderId.Size()
		n += 1 + l + sovOffChainUpdates(uint64(l))
	}
	if m.TotalFilledQuantums != 0 {
		n += 1 + sovOffChainUpdates(uint64(m.TotalFilledQuantums))
	}
	return n
}

func (m *OffChainUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UpdateMessage != nil {
		n += m.UpdateMessage.Size()
	}
	return n
}

func (m *OffChainUpdate_OrderPlace) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OrderPlace != nil {
		l = m.OrderPlace.Size()
		n += 1 + l + sovOffChainUpdates(uint64(l))
	}
	return n
}
func (m *OffChainUpdate_OrderRemove) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OrderRemove != nil {
		l = m.OrderRemove.Size()
		n += 1 + l + sovOffChainUpdates(uint64(l))
	}
	return n
}
func (m *OffChainUpdate_OrderUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OrderUpdate != nil {
		l = m.OrderUpdate.Size()
		n += 1 + l + sovOffChainUpdates(uint64(l))
	}
	return n
}

func sovOffChainUpdates(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozOffChainUpdates(x uint64) (n int) {
	return sovOffChainUpdates(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *OrderPlace) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOffChainUpdates
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrderPlace: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrderPlace: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOffChainUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOffChainUpdates
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOffChainUpdates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Order == nil {
				m.Order = &types.Order{}
			}
			if err := m.Order.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlacementStatus", wireType)
			}
			m.PlacementStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOffChainUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlacementStatus |= OrderPlace_OrderPlacementStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOffChainUpdates(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOffChainUpdates
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrderRemove) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOffChainUpdates
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrderRemove: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrderRemove: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemovedOrderId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOffChainUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOffChainUpdates
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOffChainUpdates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RemovedOrderId == nil {
				m.RemovedOrderId = &types.OrderId{}
			}
			if err := m.RemovedOrderId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			m.Reason = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOffChainUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Reason |= OrderRemove_OrderRemovalReason(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemovalStatus", wireType)
			}
			m.RemovalStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOffChainUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RemovalStatus |= OrderRemove_OrderRemovalStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOffChainUpdates(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOffChainUpdates
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrderUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOffChainUpdates
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrderUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrderUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOffChainUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOffChainUpdates
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOffChainUpdates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OrderId == nil {
				m.OrderId = &types.OrderId{}
			}
			if err := m.OrderId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalFilledQuantums", wireType)
			}
			m.TotalFilledQuantums = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOffChainUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalFilledQuantums |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOffChainUpdates(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOffChainUpdates
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OffChainUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOffChainUpdates
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OffChainUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OffChainUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderPlace", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOffChainUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOffChainUpdates
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOffChainUpdates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &OrderPlace{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.UpdateMessage = &OffChainUpdate_OrderPlace{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderRemove", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOffChainUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOffChainUpdates
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOffChainUpdates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &OrderRemove{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.UpdateMessage = &OffChainUpdate_OrderRemove{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderUpdate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOffChainUpdates
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthOffChainUpdates
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthOffChainUpdates
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &OrderUpdate{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.UpdateMessage = &OffChainUpdate_OrderUpdate{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipOffChainUpdates(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthOffChainUpdates
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipOffChainUpdates(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowOffChainUpdates
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOffChainUpdates
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOffChainUpdates
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthOffChainUpdates
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupOffChainUpdates
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthOffChainUpdates
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthOffChainUpdates        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowOffChainUpdates          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupOffChainUpdates = fmt.Errorf("proto: unexpected end of group")
)
