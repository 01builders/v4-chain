// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: dydxprotocol/indexer/events/events.proto

package events

import (
	fmt "fmt"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	github_com_dydxprotocol_v4_dtypes "github.com/dydxprotocol/v4/dtypes"
	types1 "github.com/dydxprotocol/v4/x/clob/types"
	types "github.com/dydxprotocol/v4/x/subaccounts/types"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Type is the type for funding values.
type FundingEvent_Type int32

const (
	// Unspecified type.
	FundingEvent_TYPE_UNSPECIFIED FundingEvent_Type = 0
	// Premium sample is the combined value from all premium votes during a
	// `funding-sample` epoch.
	FundingEvent_TYPE_PREMIUM_SAMPLE FundingEvent_Type = 1
	// Funding rate is the final funding rate combining all premium samples
	// during a `funding-tick` epoch.
	FundingEvent_TYPE_FUNDING_RATE_AND_INDEX FundingEvent_Type = 2
	// TODO(DEC-1513): Investigate whether premium vote values need to be
	// sent to indexer.
	FundingEvent_TYPE_PREMIUM_VOTE FundingEvent_Type = 3
)

var FundingEvent_Type_name = map[int32]string{
	0: "TYPE_UNSPECIFIED",
	1: "TYPE_PREMIUM_SAMPLE",
	2: "TYPE_FUNDING_RATE_AND_INDEX",
	3: "TYPE_PREMIUM_VOTE",
}

var FundingEvent_Type_value = map[string]int32{
	"TYPE_UNSPECIFIED":            0,
	"TYPE_PREMIUM_SAMPLE":         1,
	"TYPE_FUNDING_RATE_AND_INDEX": 2,
	"TYPE_PREMIUM_VOTE":           3,
}

func (x FundingEvent_Type) String() string {
	return proto.EnumName(FundingEvent_Type_name, int32(x))
}

func (FundingEvent_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6331dfb59c6fd2bb, []int{1, 0}
}

// FundingUpdate is used for funding update events and includes a funding
// value and an optional funding index that correspond to a perpetual market.
type FundingUpdate struct {
	// The id of the perpetual market.
	PerpetualId uint32 `protobuf:"varint,1,opt,name=perpetual_id,json=perpetualId,proto3" json:"perpetual_id,omitempty"`
	// funding value (in parts-per-million) can be premium vote, premium sample,
	// or funding rate.
	FundingValuePpm int32 `protobuf:"varint,2,opt,name=funding_value_ppm,json=fundingValuePpm,proto3" json:"funding_value_ppm,omitempty"`
	// funding index is required if and only if parent `FundingEvent` type is
	// `TYPE_FUNDING_RATE_AND_INDEX`.
	FundingIndex github_com_dydxprotocol_v4_dtypes.SerializableInt `protobuf:"bytes,3,opt,name=funding_index,json=fundingIndex,proto3,customtype=github.com/dydxprotocol/v4/dtypes.SerializableInt" json:"funding_index"`
}

func (m *FundingUpdate) Reset()         { *m = FundingUpdate{} }
func (m *FundingUpdate) String() string { return proto.CompactTextString(m) }
func (*FundingUpdate) ProtoMessage()    {}
func (*FundingUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptor_6331dfb59c6fd2bb, []int{0}
}
func (m *FundingUpdate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FundingUpdate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FundingUpdate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FundingUpdate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FundingUpdate.Merge(m, src)
}
func (m *FundingUpdate) XXX_Size() int {
	return m.Size()
}
func (m *FundingUpdate) XXX_DiscardUnknown() {
	xxx_messageInfo_FundingUpdate.DiscardUnknown(m)
}

var xxx_messageInfo_FundingUpdate proto.InternalMessageInfo

func (m *FundingUpdate) GetPerpetualId() uint32 {
	if m != nil {
		return m.PerpetualId
	}
	return 0
}

func (m *FundingUpdate) GetFundingValuePpm() int32 {
	if m != nil {
		return m.FundingValuePpm
	}
	return 0
}

// FundingEvent message contains a list of per-market funding values. The
// funding values in the list is of the same type and the types are: which can
// have one of the following types:
//  1. Premium vote: votes on the premium values injected by block proposers.
//  2. Premium sample: combined value from all premium votes during a
//     `funding-sample` epoch.
//  3. Funding rate and index: final funding rate combining all premium samples
//     during a `funding-tick` epoch and funding index accordingly updated with
//     `funding rate * price`.
type FundingEvent struct {
	// updates is a list of per-market funding updates for all existing perpetual
	// markets. The list is sorted by `perpetualId`s which are unique.
	Updates []FundingUpdate `protobuf:"bytes,1,rep,name=updates,proto3" json:"updates"`
	// type stores the type of funding updates.
	Type FundingEvent_Type `protobuf:"varint,2,opt,name=type,proto3,enum=dydxprotocol.indexer.events.FundingEvent_Type" json:"type,omitempty"`
}

func (m *FundingEvent) Reset()         { *m = FundingEvent{} }
func (m *FundingEvent) String() string { return proto.CompactTextString(m) }
func (*FundingEvent) ProtoMessage()    {}
func (*FundingEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_6331dfb59c6fd2bb, []int{1}
}
func (m *FundingEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FundingEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FundingEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FundingEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FundingEvent.Merge(m, src)
}
func (m *FundingEvent) XXX_Size() int {
	return m.Size()
}
func (m *FundingEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_FundingEvent.DiscardUnknown(m)
}

var xxx_messageInfo_FundingEvent proto.InternalMessageInfo

func (m *FundingEvent) GetUpdates() []FundingUpdate {
	if m != nil {
		return m.Updates
	}
	return nil
}

func (m *FundingEvent) GetType() FundingEvent_Type {
	if m != nil {
		return m.Type
	}
	return FundingEvent_TYPE_UNSPECIFIED
}

// MarketEvent message contains all the information about a market event on
// the V4 chain.
type MarketEvent struct {
	// market id.
	MarketId uint32 `protobuf:"varint,1,opt,name=market_id,json=marketId,proto3" json:"market_id,omitempty"`
	// either an event for price update, market creation, or market modification.
	//
	// Types that are valid to be assigned to Event:
	//	*MarketEvent_PriceUpdate
	//	*MarketEvent_MarketCreate
	//	*MarketEvent_MarketModify
	Event isMarketEvent_Event `protobuf_oneof:"event"`
}

func (m *MarketEvent) Reset()         { *m = MarketEvent{} }
func (m *MarketEvent) String() string { return proto.CompactTextString(m) }
func (*MarketEvent) ProtoMessage()    {}
func (*MarketEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_6331dfb59c6fd2bb, []int{2}
}
func (m *MarketEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MarketEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MarketEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MarketEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MarketEvent.Merge(m, src)
}
func (m *MarketEvent) XXX_Size() int {
	return m.Size()
}
func (m *MarketEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_MarketEvent.DiscardUnknown(m)
}

var xxx_messageInfo_MarketEvent proto.InternalMessageInfo

type isMarketEvent_Event interface {
	isMarketEvent_Event()
	MarshalTo([]byte) (int, error)
	Size() int
}

type MarketEvent_PriceUpdate struct {
	PriceUpdate *MarketPriceUpdateEvent `protobuf:"bytes,2,opt,name=price_update,json=priceUpdate,proto3,oneof" json:"price_update,omitempty"`
}
type MarketEvent_MarketCreate struct {
	MarketCreate *MarketCreateEvent `protobuf:"bytes,3,opt,name=market_create,json=marketCreate,proto3,oneof" json:"market_create,omitempty"`
}
type MarketEvent_MarketModify struct {
	MarketModify *MarketModifyEvent `protobuf:"bytes,4,opt,name=market_modify,json=marketModify,proto3,oneof" json:"market_modify,omitempty"`
}

func (*MarketEvent_PriceUpdate) isMarketEvent_Event()  {}
func (*MarketEvent_MarketCreate) isMarketEvent_Event() {}
func (*MarketEvent_MarketModify) isMarketEvent_Event() {}

func (m *MarketEvent) GetEvent() isMarketEvent_Event {
	if m != nil {
		return m.Event
	}
	return nil
}

func (m *MarketEvent) GetMarketId() uint32 {
	if m != nil {
		return m.MarketId
	}
	return 0
}

func (m *MarketEvent) GetPriceUpdate() *MarketPriceUpdateEvent {
	if x, ok := m.GetEvent().(*MarketEvent_PriceUpdate); ok {
		return x.PriceUpdate
	}
	return nil
}

func (m *MarketEvent) GetMarketCreate() *MarketCreateEvent {
	if x, ok := m.GetEvent().(*MarketEvent_MarketCreate); ok {
		return x.MarketCreate
	}
	return nil
}

func (m *MarketEvent) GetMarketModify() *MarketModifyEvent {
	if x, ok := m.GetEvent().(*MarketEvent_MarketModify); ok {
		return x.MarketModify
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*MarketEvent) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*MarketEvent_PriceUpdate)(nil),
		(*MarketEvent_MarketCreate)(nil),
		(*MarketEvent_MarketModify)(nil),
	}
}

// MarketPriceUpdateEvent message contains all the information about a price
// update on the V4 chain.
type MarketPriceUpdateEvent struct {
	// price_with_exponent. Multiply by 10 ^ Exponent to get the human readable
	// price in dollars. For example if `Exponent == -5` then a `exponent_price`
	// of `1,000,000,000` represents “$10,000`.
	PriceWithExponent uint64 `protobuf:"varint,1,opt,name=price_with_exponent,json=priceWithExponent,proto3" json:"price_with_exponent,omitempty"`
}

func (m *MarketPriceUpdateEvent) Reset()         { *m = MarketPriceUpdateEvent{} }
func (m *MarketPriceUpdateEvent) String() string { return proto.CompactTextString(m) }
func (*MarketPriceUpdateEvent) ProtoMessage()    {}
func (*MarketPriceUpdateEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_6331dfb59c6fd2bb, []int{3}
}
func (m *MarketPriceUpdateEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MarketPriceUpdateEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MarketPriceUpdateEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MarketPriceUpdateEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MarketPriceUpdateEvent.Merge(m, src)
}
func (m *MarketPriceUpdateEvent) XXX_Size() int {
	return m.Size()
}
func (m *MarketPriceUpdateEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_MarketPriceUpdateEvent.DiscardUnknown(m)
}

var xxx_messageInfo_MarketPriceUpdateEvent proto.InternalMessageInfo

func (m *MarketPriceUpdateEvent) GetPriceWithExponent() uint64 {
	if m != nil {
		return m.PriceWithExponent
	}
	return 0
}

// shared fields between MarketCreateEvent and MarketModifyEvent
type MarketBaseEvent struct {
	// String representation of the market pair, e.g. `BTC-USD`
	Pair string `protobuf:"bytes,1,opt,name=pair,proto3" json:"pair,omitempty"`
	// The minimum allowable change in the Price value for a given update.
	// Measured as 1e-6.
	MinPriceChangePpm uint32 `protobuf:"varint,2,opt,name=min_price_change_ppm,json=minPriceChangePpm,proto3" json:"min_price_change_ppm,omitempty"`
}

func (m *MarketBaseEvent) Reset()         { *m = MarketBaseEvent{} }
func (m *MarketBaseEvent) String() string { return proto.CompactTextString(m) }
func (*MarketBaseEvent) ProtoMessage()    {}
func (*MarketBaseEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_6331dfb59c6fd2bb, []int{4}
}
func (m *MarketBaseEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MarketBaseEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MarketBaseEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MarketBaseEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MarketBaseEvent.Merge(m, src)
}
func (m *MarketBaseEvent) XXX_Size() int {
	return m.Size()
}
func (m *MarketBaseEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_MarketBaseEvent.DiscardUnknown(m)
}

var xxx_messageInfo_MarketBaseEvent proto.InternalMessageInfo

func (m *MarketBaseEvent) GetPair() string {
	if m != nil {
		return m.Pair
	}
	return ""
}

func (m *MarketBaseEvent) GetMinPriceChangePpm() uint32 {
	if m != nil {
		return m.MinPriceChangePpm
	}
	return 0
}

// MarketCreateEvent message contains all the information about a new market on
// the V4 chain.
type MarketCreateEvent struct {
	Base *MarketBaseEvent `protobuf:"bytes,1,opt,name=base,proto3" json:"base,omitempty"`
	// Static value. The exponent of the price.
	// For example if Exponent == -5 then a `exponent_price` of 1,000,000,000
	// represents $10,000. Therefore 10 ^ Exponent represents the smallest
	// price step (in dollars) that can be recorded.
	Exponent int32 `protobuf:"zigzag32,2,opt,name=exponent,proto3" json:"exponent,omitempty"`
}

func (m *MarketCreateEvent) Reset()         { *m = MarketCreateEvent{} }
func (m *MarketCreateEvent) String() string { return proto.CompactTextString(m) }
func (*MarketCreateEvent) ProtoMessage()    {}
func (*MarketCreateEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_6331dfb59c6fd2bb, []int{5}
}
func (m *MarketCreateEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MarketCreateEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MarketCreateEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MarketCreateEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MarketCreateEvent.Merge(m, src)
}
func (m *MarketCreateEvent) XXX_Size() int {
	return m.Size()
}
func (m *MarketCreateEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_MarketCreateEvent.DiscardUnknown(m)
}

var xxx_messageInfo_MarketCreateEvent proto.InternalMessageInfo

func (m *MarketCreateEvent) GetBase() *MarketBaseEvent {
	if m != nil {
		return m.Base
	}
	return nil
}

func (m *MarketCreateEvent) GetExponent() int32 {
	if m != nil {
		return m.Exponent
	}
	return 0
}

// MarketModifyEvent message contains all the information about a market update
// on the V4 chain
type MarketModifyEvent struct {
	Base *MarketBaseEvent `protobuf:"bytes,1,opt,name=base,proto3" json:"base,omitempty"`
}

func (m *MarketModifyEvent) Reset()         { *m = MarketModifyEvent{} }
func (m *MarketModifyEvent) String() string { return proto.CompactTextString(m) }
func (*MarketModifyEvent) ProtoMessage()    {}
func (*MarketModifyEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_6331dfb59c6fd2bb, []int{6}
}
func (m *MarketModifyEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MarketModifyEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MarketModifyEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MarketModifyEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MarketModifyEvent.Merge(m, src)
}
func (m *MarketModifyEvent) XXX_Size() int {
	return m.Size()
}
func (m *MarketModifyEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_MarketModifyEvent.DiscardUnknown(m)
}

var xxx_messageInfo_MarketModifyEvent proto.InternalMessageInfo

func (m *MarketModifyEvent) GetBase() *MarketBaseEvent {
	if m != nil {
		return m.Base
	}
	return nil
}

// TransferEvent message contains all the information about a transfer on
// the V4 chain. A transfer also produces 2 separate SubaccountUpdateEvent
// messages, 1 for recipient and 1 for sender, with the updated asset
// positions.
type TransferEvent struct {
	// The sender subaccount ID.
	SenderSubaccountId types.SubaccountId `protobuf:"bytes,1,opt,name=sender_subaccount_id,json=senderSubaccountId,proto3" json:"sender_subaccount_id"`
	// The recipient subaccount ID.
	RecipientSubaccountId types.SubaccountId `protobuf:"bytes,2,opt,name=recipient_subaccount_id,json=recipientSubaccountId,proto3" json:"recipient_subaccount_id"`
	// Id of the asset transfered.
	AssetId uint32 `protobuf:"varint,3,opt,name=asset_id,json=assetId,proto3" json:"asset_id,omitempty"`
	// The amount of asset in quantums to transfer.
	Amount uint64 `protobuf:"varint,4,opt,name=amount,proto3" json:"amount,omitempty"`
}

func (m *TransferEvent) Reset()         { *m = TransferEvent{} }
func (m *TransferEvent) String() string { return proto.CompactTextString(m) }
func (*TransferEvent) ProtoMessage()    {}
func (*TransferEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_6331dfb59c6fd2bb, []int{7}
}
func (m *TransferEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransferEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransferEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TransferEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransferEvent.Merge(m, src)
}
func (m *TransferEvent) XXX_Size() int {
	return m.Size()
}
func (m *TransferEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_TransferEvent.DiscardUnknown(m)
}

var xxx_messageInfo_TransferEvent proto.InternalMessageInfo

func (m *TransferEvent) GetSenderSubaccountId() types.SubaccountId {
	if m != nil {
		return m.SenderSubaccountId
	}
	return types.SubaccountId{}
}

func (m *TransferEvent) GetRecipientSubaccountId() types.SubaccountId {
	if m != nil {
		return m.RecipientSubaccountId
	}
	return types.SubaccountId{}
}

func (m *TransferEvent) GetAssetId() uint32 {
	if m != nil {
		return m.AssetId
	}
	return 0
}

func (m *TransferEvent) GetAmount() uint64 {
	if m != nil {
		return m.Amount
	}
	return 0
}

// OrderFillEvent message contains all the information from an order match in
// the V4 chain. This includes the maker/taker orders that matched and the
// amount filled.
type OrderFillEvent struct {
	MakerOrder types1.Order `protobuf:"bytes,1,opt,name=maker_order,json=makerOrder,proto3" json:"maker_order"`
	// The type of order fill this event represents.
	//
	// Types that are valid to be assigned to TakerOrder:
	//
	//	*OrderFillEvent_Order
	//	*OrderFillEvent_LiquidationOrder
	TakerOrder isOrderFillEvent_TakerOrder `protobuf_oneof:"taker_order"`
	FillAmount uint64                      `protobuf:"varint,3,opt,name=fill_amount,json=fillAmount,proto3" json:"fill_amount,omitempty"`
}

func (m *OrderFillEvent) Reset()         { *m = OrderFillEvent{} }
func (m *OrderFillEvent) String() string { return proto.CompactTextString(m) }
func (*OrderFillEvent) ProtoMessage()    {}
func (*OrderFillEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_6331dfb59c6fd2bb, []int{8}
}
func (m *OrderFillEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OrderFillEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OrderFillEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OrderFillEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OrderFillEvent.Merge(m, src)
}
func (m *OrderFillEvent) XXX_Size() int {
	return m.Size()
}
func (m *OrderFillEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_OrderFillEvent.DiscardUnknown(m)
}

var xxx_messageInfo_OrderFillEvent proto.InternalMessageInfo

type isOrderFillEvent_TakerOrder interface {
	isOrderFillEvent_TakerOrder()
	MarshalTo([]byte) (int, error)
	Size() int
}

type OrderFillEvent_Order struct {
	Order *types1.Order `protobuf:"bytes,2,opt,name=order,proto3,oneof" json:"order,omitempty"`
}
type OrderFillEvent_LiquidationOrder struct {
	LiquidationOrder *LiquidationOrder `protobuf:"bytes,4,opt,name=liquidation_order,json=liquidationOrder,proto3,oneof" json:"liquidation_order,omitempty"`
}

func (*OrderFillEvent_Order) isOrderFillEvent_TakerOrder()            {}
func (*OrderFillEvent_LiquidationOrder) isOrderFillEvent_TakerOrder() {}

func (m *OrderFillEvent) GetTakerOrder() isOrderFillEvent_TakerOrder {
	if m != nil {
		return m.TakerOrder
	}
	return nil
}

func (m *OrderFillEvent) GetMakerOrder() types1.Order {
	if m != nil {
		return m.MakerOrder
	}
	return types1.Order{}
}

func (m *OrderFillEvent) GetOrder() *types1.Order {
	if x, ok := m.GetTakerOrder().(*OrderFillEvent_Order); ok {
		return x.Order
	}
	return nil
}

func (m *OrderFillEvent) GetLiquidationOrder() *LiquidationOrder {
	if x, ok := m.GetTakerOrder().(*OrderFillEvent_LiquidationOrder); ok {
		return x.LiquidationOrder
	}
	return nil
}

func (m *OrderFillEvent) GetFillAmount() uint64 {
	if m != nil {
		return m.FillAmount
	}
	return 0
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*OrderFillEvent) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*OrderFillEvent_Order)(nil),
		(*OrderFillEvent_LiquidationOrder)(nil),
	}
}

// LiquidationOrder represents the liquidation taker order to be included in a
// liquidation order fill event.
type LiquidationOrder struct {
	// ID of the subaccount that was liquidated.
	Liquidated types.SubaccountId `protobuf:"bytes,1,opt,name=liquidated,proto3" json:"liquidated"`
	// The ID of the clob pair involved in the liquidation.
	ClobPairId uint32 `protobuf:"varint,2,opt,name=clob_pair_id,json=clobPairId,proto3" json:"clob_pair_id,omitempty"`
	// The ID of the perpetual involved in the liquidation.
	PerpetualId uint32 `protobuf:"varint,3,opt,name=perpetual_id,json=perpetualId,proto3" json:"perpetual_id,omitempty"`
	// The total size of the liquidation order including any unfilled size,
	// in base quantums.
	TotalSize uint64 `protobuf:"varint,4,opt,name=total_size,json=totalSize,proto3" json:"total_size,omitempty"`
	// `true` if liquidating a short position, `false` otherwise.
	IsBuy bool `protobuf:"varint,5,opt,name=is_buy,json=isBuy,proto3" json:"is_buy,omitempty"`
	// The fillable price in subticks.
	// This represents the lower-price-bound for liquidating longs
	// and the upper-price-bound for liquidating shorts.
	// Must be a multiple of ClobPair.SubticksPerTick
	// (where `ClobPair.Id = orderId.ClobPairId`).
	Subticks uint64 `protobuf:"varint,6,opt,name=subticks,proto3" json:"subticks,omitempty"`
}

func (m *LiquidationOrder) Reset()         { *m = LiquidationOrder{} }
func (m *LiquidationOrder) String() string { return proto.CompactTextString(m) }
func (*LiquidationOrder) ProtoMessage()    {}
func (*LiquidationOrder) Descriptor() ([]byte, []int) {
	return fileDescriptor_6331dfb59c6fd2bb, []int{9}
}
func (m *LiquidationOrder) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LiquidationOrder) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LiquidationOrder.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LiquidationOrder) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LiquidationOrder.Merge(m, src)
}
func (m *LiquidationOrder) XXX_Size() int {
	return m.Size()
}
func (m *LiquidationOrder) XXX_DiscardUnknown() {
	xxx_messageInfo_LiquidationOrder.DiscardUnknown(m)
}

var xxx_messageInfo_LiquidationOrder proto.InternalMessageInfo

func (m *LiquidationOrder) GetLiquidated() types.SubaccountId {
	if m != nil {
		return m.Liquidated
	}
	return types.SubaccountId{}
}

func (m *LiquidationOrder) GetClobPairId() uint32 {
	if m != nil {
		return m.ClobPairId
	}
	return 0
}

func (m *LiquidationOrder) GetPerpetualId() uint32 {
	if m != nil {
		return m.PerpetualId
	}
	return 0
}

func (m *LiquidationOrder) GetTotalSize() uint64 {
	if m != nil {
		return m.TotalSize
	}
	return 0
}

func (m *LiquidationOrder) GetIsBuy() bool {
	if m != nil {
		return m.IsBuy
	}
	return false
}

func (m *LiquidationOrder) GetSubticks() uint64 {
	if m != nil {
		return m.Subticks
	}
	return 0
}

// SubaccountUpdateEvent message contains information about an update to a
// subaccount in the V4 chain. This includes the list of updated perpetual
// and asset positions for the subaccount.
// Note: This event message will contain all the updates to a subaccount
// at the end of a block which is why multiple asset/perpetual position
// updates may exist.
type SubaccountUpdateEvent struct {
	SubaccountId *types.SubaccountId `protobuf:"bytes,1,opt,name=subaccount_id,json=subaccountId,proto3" json:"subaccount_id,omitempty"`
	// updated_perpetual_positions will each be for unique perpetuals.
	UpdatedPerpetualPositions []*types.PerpetualPosition `protobuf:"bytes,3,rep,name=updated_perpetual_positions,json=updatedPerpetualPositions,proto3" json:"updated_perpetual_positions,omitempty"`
	// updated_asset_positions will each be for unique assets.
	UpdatedAssetPositions []*types.AssetPosition `protobuf:"bytes,4,rep,name=updated_asset_positions,json=updatedAssetPositions,proto3" json:"updated_asset_positions,omitempty"`
}

func (m *SubaccountUpdateEvent) Reset()         { *m = SubaccountUpdateEvent{} }
func (m *SubaccountUpdateEvent) String() string { return proto.CompactTextString(m) }
func (*SubaccountUpdateEvent) ProtoMessage()    {}
func (*SubaccountUpdateEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_6331dfb59c6fd2bb, []int{10}
}
func (m *SubaccountUpdateEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubaccountUpdateEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubaccountUpdateEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubaccountUpdateEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubaccountUpdateEvent.Merge(m, src)
}
func (m *SubaccountUpdateEvent) XXX_Size() int {
	return m.Size()
}
func (m *SubaccountUpdateEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_SubaccountUpdateEvent.DiscardUnknown(m)
}

var xxx_messageInfo_SubaccountUpdateEvent proto.InternalMessageInfo

func (m *SubaccountUpdateEvent) GetSubaccountId() *types.SubaccountId {
	if m != nil {
		return m.SubaccountId
	}
	return nil
}

func (m *SubaccountUpdateEvent) GetUpdatedPerpetualPositions() []*types.PerpetualPosition {
	if m != nil {
		return m.UpdatedPerpetualPositions
	}
	return nil
}

func (m *SubaccountUpdateEvent) GetUpdatedAssetPositions() []*types.AssetPosition {
	if m != nil {
		return m.UpdatedAssetPositions
	}
	return nil
}

// StatefulOrderEvent message contains information about a change to a stateful
// order. Currently, this is either the placement, cancelation, or expiration of
// a stateful order.
type StatefulOrderEvent struct {
	// The type of event that this StatefulOrderEvent contains.
	//
	// Types that are valid to be assigned to Event:
	//
	//	*StatefulOrderEvent_OrderPlace
	//	*StatefulOrderEvent_OrderCancel
	//	*StatefulOrderEvent_OrderExpiration
	Event isStatefulOrderEvent_Event `protobuf_oneof:"event"`
}

func (m *StatefulOrderEvent) Reset()         { *m = StatefulOrderEvent{} }
func (m *StatefulOrderEvent) String() string { return proto.CompactTextString(m) }
func (*StatefulOrderEvent) ProtoMessage()    {}
func (*StatefulOrderEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_6331dfb59c6fd2bb, []int{11}
}
func (m *StatefulOrderEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StatefulOrderEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StatefulOrderEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StatefulOrderEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StatefulOrderEvent.Merge(m, src)
}
func (m *StatefulOrderEvent) XXX_Size() int {
	return m.Size()
}
func (m *StatefulOrderEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_StatefulOrderEvent.DiscardUnknown(m)
}

var xxx_messageInfo_StatefulOrderEvent proto.InternalMessageInfo

type isStatefulOrderEvent_Event interface {
	isStatefulOrderEvent_Event()
	MarshalTo([]byte) (int, error)
	Size() int
}

type StatefulOrderEvent_OrderPlace struct {
	OrderPlace *StatefulOrderEvent_StatefulOrderPlacement `protobuf:"bytes,1,opt,name=order_place,json=orderPlace,proto3,oneof" json:"order_place,omitempty"`
}
type StatefulOrderEvent_OrderCancel struct {
	OrderCancel *StatefulOrderEvent_StatefulOrderCancelation `protobuf:"bytes,2,opt,name=order_cancel,json=orderCancel,proto3,oneof" json:"order_cancel,omitempty"`
}
type StatefulOrderEvent_OrderExpiration struct {
	OrderExpiration *StatefulOrderEvent_StatefulOrderExpiration `protobuf:"bytes,3,opt,name=order_expiration,json=orderExpiration,proto3,oneof" json:"order_expiration,omitempty"`
}

func (*StatefulOrderEvent_OrderPlace) isStatefulOrderEvent_Event()      {}
func (*StatefulOrderEvent_OrderCancel) isStatefulOrderEvent_Event()     {}
func (*StatefulOrderEvent_OrderExpiration) isStatefulOrderEvent_Event() {}

func (m *StatefulOrderEvent) GetEvent() isStatefulOrderEvent_Event {
	if m != nil {
		return m.Event
	}
	return nil
}

func (m *StatefulOrderEvent) GetOrderPlace() *StatefulOrderEvent_StatefulOrderPlacement {
	if x, ok := m.GetEvent().(*StatefulOrderEvent_OrderPlace); ok {
		return x.OrderPlace
	}
	return nil
}

func (m *StatefulOrderEvent) GetOrderCancel() *StatefulOrderEvent_StatefulOrderCancelation {
	if x, ok := m.GetEvent().(*StatefulOrderEvent_OrderCancel); ok {
		return x.OrderCancel
	}
	return nil
}

func (m *StatefulOrderEvent) GetOrderExpiration() *StatefulOrderEvent_StatefulOrderExpiration {
	if x, ok := m.GetEvent().(*StatefulOrderEvent_OrderExpiration); ok {
		return x.OrderExpiration
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*StatefulOrderEvent) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*StatefulOrderEvent_OrderPlace)(nil),
		(*StatefulOrderEvent_OrderCancel)(nil),
		(*StatefulOrderEvent_OrderExpiration)(nil),
	}
}

// A stateful order placement contains an order.
type StatefulOrderEvent_StatefulOrderPlacement struct {
	Order *types1.Order `protobuf:"bytes,1,opt,name=order,proto3" json:"order,omitempty"`
}

func (m *StatefulOrderEvent_StatefulOrderPlacement) Reset() {
	*m = StatefulOrderEvent_StatefulOrderPlacement{}
}
func (m *StatefulOrderEvent_StatefulOrderPlacement) String() string {
	return proto.CompactTextString(m)
}
func (*StatefulOrderEvent_StatefulOrderPlacement) ProtoMessage() {}
func (*StatefulOrderEvent_StatefulOrderPlacement) Descriptor() ([]byte, []int) {
	return fileDescriptor_6331dfb59c6fd2bb, []int{11, 0}
}
func (m *StatefulOrderEvent_StatefulOrderPlacement) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StatefulOrderEvent_StatefulOrderPlacement) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StatefulOrderEvent_StatefulOrderPlacement.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StatefulOrderEvent_StatefulOrderPlacement) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StatefulOrderEvent_StatefulOrderPlacement.Merge(m, src)
}
func (m *StatefulOrderEvent_StatefulOrderPlacement) XXX_Size() int {
	return m.Size()
}
func (m *StatefulOrderEvent_StatefulOrderPlacement) XXX_DiscardUnknown() {
	xxx_messageInfo_StatefulOrderEvent_StatefulOrderPlacement.DiscardUnknown(m)
}

var xxx_messageInfo_StatefulOrderEvent_StatefulOrderPlacement proto.InternalMessageInfo

func (m *StatefulOrderEvent_StatefulOrderPlacement) GetOrder() *types1.Order {
	if m != nil {
		return m.Order
	}
	return nil
}

// A stateful order cancelation contains the id of an order that was already
// placed and is now cancelled.
type StatefulOrderEvent_StatefulOrderCancelation struct {
	CanceledOrderId *types1.OrderId `protobuf:"bytes,1,opt,name=canceled_order_id,json=canceledOrderId,proto3" json:"canceled_order_id,omitempty"`
}

func (m *StatefulOrderEvent_StatefulOrderCancelation) Reset() {
	*m = StatefulOrderEvent_StatefulOrderCancelation{}
}
func (m *StatefulOrderEvent_StatefulOrderCancelation) String() string {
	return proto.CompactTextString(m)
}
func (*StatefulOrderEvent_StatefulOrderCancelation) ProtoMessage() {}
func (*StatefulOrderEvent_StatefulOrderCancelation) Descriptor() ([]byte, []int) {
	return fileDescriptor_6331dfb59c6fd2bb, []int{11, 1}
}
func (m *StatefulOrderEvent_StatefulOrderCancelation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StatefulOrderEvent_StatefulOrderCancelation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StatefulOrderEvent_StatefulOrderCancelation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StatefulOrderEvent_StatefulOrderCancelation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StatefulOrderEvent_StatefulOrderCancelation.Merge(m, src)
}
func (m *StatefulOrderEvent_StatefulOrderCancelation) XXX_Size() int {
	return m.Size()
}
func (m *StatefulOrderEvent_StatefulOrderCancelation) XXX_DiscardUnknown() {
	xxx_messageInfo_StatefulOrderEvent_StatefulOrderCancelation.DiscardUnknown(m)
}

var xxx_messageInfo_StatefulOrderEvent_StatefulOrderCancelation proto.InternalMessageInfo

func (m *StatefulOrderEvent_StatefulOrderCancelation) GetCanceledOrderId() *types1.OrderId {
	if m != nil {
		return m.CanceledOrderId
	}
	return nil
}

// A stateful order expiration contains the id of an order that was already
// placed and is now expired.
type StatefulOrderEvent_StatefulOrderExpiration struct {
	ExpiredOrderId *types1.OrderId `protobuf:"bytes,1,opt,name=expired_order_id,json=expiredOrderId,proto3" json:"expired_order_id,omitempty"`
}

func (m *StatefulOrderEvent_StatefulOrderExpiration) Reset() {
	*m = StatefulOrderEvent_StatefulOrderExpiration{}
}
func (m *StatefulOrderEvent_StatefulOrderExpiration) String() string {
	return proto.CompactTextString(m)
}
func (*StatefulOrderEvent_StatefulOrderExpiration) ProtoMessage() {}
func (*StatefulOrderEvent_StatefulOrderExpiration) Descriptor() ([]byte, []int) {
	return fileDescriptor_6331dfb59c6fd2bb, []int{11, 2}
}
func (m *StatefulOrderEvent_StatefulOrderExpiration) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StatefulOrderEvent_StatefulOrderExpiration) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StatefulOrderEvent_StatefulOrderExpiration.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StatefulOrderEvent_StatefulOrderExpiration) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StatefulOrderEvent_StatefulOrderExpiration.Merge(m, src)
}
func (m *StatefulOrderEvent_StatefulOrderExpiration) XXX_Size() int {
	return m.Size()
}
func (m *StatefulOrderEvent_StatefulOrderExpiration) XXX_DiscardUnknown() {
	xxx_messageInfo_StatefulOrderEvent_StatefulOrderExpiration.DiscardUnknown(m)
}

var xxx_messageInfo_StatefulOrderEvent_StatefulOrderExpiration proto.InternalMessageInfo

func (m *StatefulOrderEvent_StatefulOrderExpiration) GetExpiredOrderId() *types1.OrderId {
	if m != nil {
		return m.ExpiredOrderId
	}
	return nil
}

func init() {
	proto.RegisterEnum("dydxprotocol.indexer.events.FundingEvent_Type", FundingEvent_Type_name, FundingEvent_Type_value)
	proto.RegisterType((*FundingUpdate)(nil), "dydxprotocol.indexer.events.FundingUpdate")
	proto.RegisterType((*FundingEvent)(nil), "dydxprotocol.indexer.events.FundingEvent")
	proto.RegisterType((*MarketEvent)(nil), "dydxprotocol.indexer.events.MarketEvent")
	proto.RegisterType((*MarketPriceUpdateEvent)(nil), "dydxprotocol.indexer.events.MarketPriceUpdateEvent")
	proto.RegisterType((*MarketBaseEvent)(nil), "dydxprotocol.indexer.events.MarketBaseEvent")
	proto.RegisterType((*MarketCreateEvent)(nil), "dydxprotocol.indexer.events.MarketCreateEvent")
	proto.RegisterType((*MarketModifyEvent)(nil), "dydxprotocol.indexer.events.MarketModifyEvent")
	proto.RegisterType((*TransferEvent)(nil), "dydxprotocol.indexer.events.TransferEvent")
	proto.RegisterType((*OrderFillEvent)(nil), "dydxprotocol.indexer.events.OrderFillEvent")
	proto.RegisterType((*LiquidationOrder)(nil), "dydxprotocol.indexer.events.LiquidationOrder")
	proto.RegisterType((*SubaccountUpdateEvent)(nil), "dydxprotocol.indexer.events.SubaccountUpdateEvent")
	proto.RegisterType((*StatefulOrderEvent)(nil), "dydxprotocol.indexer.events.StatefulOrderEvent")
	proto.RegisterType((*StatefulOrderEvent_StatefulOrderPlacement)(nil), "dydxprotocol.indexer.events.StatefulOrderEvent.StatefulOrderPlacement")
	proto.RegisterType((*StatefulOrderEvent_StatefulOrderCancelation)(nil), "dydxprotocol.indexer.events.StatefulOrderEvent.StatefulOrderCancelation")
	proto.RegisterType((*StatefulOrderEvent_StatefulOrderExpiration)(nil), "dydxprotocol.indexer.events.StatefulOrderEvent.StatefulOrderExpiration")
}

func init() {
	proto.RegisterFile("dydxprotocol/indexer/events/events.proto", fileDescriptor_6331dfb59c6fd2bb)
}

var fileDescriptor_6331dfb59c6fd2bb = []byte{
	// 1232 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x57, 0x4d, 0x6f, 0xdb, 0x46,
	0x13, 0x16, 0x25, 0xd9, 0x71, 0x46, 0x52, 0x2c, 0x6d, 0xec, 0x58, 0x91, 0x11, 0x59, 0x2f, 0x0f,
	0x6f, 0x95, 0xb4, 0xa1, 0x1a, 0xa7, 0x97, 0x9e, 0x5a, 0xcb, 0x96, 0x22, 0xa6, 0xb1, 0x23, 0x50,
	0x56, 0x9a, 0x16, 0x45, 0x08, 0x8a, 0x5c, 0xdb, 0x0b, 0xf3, 0x2b, 0xfc, 0x70, 0x2d, 0xff, 0x82,
	0x5e, 0x0a, 0xb4, 0xff, 0xa6, 0x40, 0x81, 0x9e, 0x73, 0xcc, 0xb1, 0xe8, 0x21, 0x28, 0xec, 0x1f,
	0xd1, 0x4b, 0x0f, 0x05, 0x77, 0x97, 0x92, 0x68, 0x45, 0xaa, 0x1b, 0x9f, 0xc4, 0x9d, 0x99, 0xe7,
	0x79, 0x76, 0x86, 0xbb, 0x33, 0x14, 0xd4, 0x8d, 0xa1, 0x71, 0xea, 0x7a, 0x4e, 0xe0, 0xe8, 0x8e,
	0xd9, 0x20, 0xb6, 0x81, 0x4f, 0xb1, 0xd7, 0xc0, 0x27, 0xd8, 0x0e, 0x7c, 0xfe, 0x23, 0x51, 0x37,
	0x5a, 0x9f, 0x8c, 0x94, 0x78, 0xa4, 0xc4, 0x42, 0x2a, 0x2b, 0x87, 0xce, 0xa1, 0x43, 0x9d, 0x8d,
	0xe8, 0x89, 0x41, 0x2a, 0xf7, 0x12, 0xe4, 0xba, 0xe9, 0x0c, 0x1a, 0x8e, 0x67, 0x60, 0x8f, 0xbb,
	0x1f, 0x26, 0xdc, 0x7e, 0x38, 0xd0, 0x74, 0xdd, 0x09, 0x23, 0x61, 0xcd, 0xf7, 0x71, 0xa0, 0xba,
	0x8e, 0x4f, 0x02, 0xe2, 0xd8, 0x3c, 0xfc, 0xd1, 0xcc, 0x70, 0x17, 0x7b, 0x2e, 0x0e, 0x42, 0xcd,
	0xbc, 0x0c, 0xb9, 0x3f, 0x13, 0x32, 0x7e, 0x66, 0xa1, 0xe2, 0x6f, 0x02, 0x14, 0xda, 0xa1, 0x6d,
	0x10, 0xfb, 0xb0, 0xef, 0x1a, 0x5a, 0x80, 0xd1, 0xff, 0x20, 0x3f, 0x26, 0x26, 0x46, 0x59, 0xa8,
	0x09, 0xf5, 0x82, 0x92, 0x1b, 0xd9, 0x64, 0x03, 0x3d, 0x80, 0xd2, 0x01, 0xc3, 0xa8, 0x27, 0x9a,
	0x19, 0x62, 0xd5, 0x75, 0xad, 0x72, 0xba, 0x26, 0xd4, 0x17, 0x94, 0x65, 0xee, 0x78, 0x11, 0xd9,
	0xbb, 0xae, 0x85, 0x5e, 0x41, 0x21, 0x8e, 0xa5, 0xc5, 0x2b, 0x67, 0x6a, 0x42, 0x3d, 0xdf, 0xfc,
	0xfc, 0xcd, 0xbb, 0x8d, 0xd4, 0x1f, 0xef, 0x36, 0x1e, 0x1d, 0x92, 0xe0, 0x28, 0x1c, 0x48, 0xba,
	0x63, 0x35, 0x12, 0xbb, 0x3e, 0xf9, 0xac, 0x61, 0x04, 0x43, 0x17, 0xfb, 0x52, 0x0f, 0x7b, 0x44,
	0x33, 0xc9, 0x99, 0x36, 0x30, 0xb1, 0x6c, 0x07, 0x4a, 0x9e, 0xf3, 0xc9, 0x11, 0x9d, 0xf8, 0x63,
	0x1a, 0xf2, 0x3c, 0x81, 0x56, 0xf4, 0x52, 0xd0, 0x53, 0xb8, 0x11, 0xd2, 0x4c, 0xfc, 0xb2, 0x50,
	0xcb, 0xd4, 0x73, 0x9b, 0x0f, 0xa4, 0x39, 0xaf, 0x50, 0x4a, 0x24, 0xdf, 0xcc, 0x46, 0xdb, 0x52,
	0x62, 0x02, 0xd4, 0x84, 0x6c, 0xb4, 0x07, 0x9a, 0xdb, 0xad, 0x4d, 0xe9, 0x2a, 0x44, 0x74, 0x13,
	0xd2, 0xfe, 0xd0, 0xc5, 0x0a, 0xc5, 0x8a, 0x16, 0x64, 0xa3, 0x15, 0x5a, 0x81, 0xe2, 0xfe, 0x37,
	0xdd, 0x96, 0xda, 0xdf, 0xeb, 0x75, 0x5b, 0xdb, 0x72, 0x5b, 0x6e, 0xed, 0x14, 0x53, 0x68, 0x0d,
	0x6e, 0x53, 0x6b, 0x57, 0x69, 0xed, 0xca, 0xfd, 0x5d, 0xb5, 0xb7, 0xb5, 0xdb, 0x7d, 0xd6, 0x2a,
	0x0a, 0x68, 0x03, 0xd6, 0xa9, 0xa3, 0xdd, 0xdf, 0xdb, 0x91, 0xf7, 0x9e, 0xa8, 0xca, 0xd6, 0x7e,
	0x4b, 0xdd, 0xda, 0xdb, 0x51, 0xe5, 0xbd, 0x9d, 0xd6, 0xcb, 0x62, 0x1a, 0xad, 0x42, 0x29, 0x81,
	0x7c, 0xf1, 0x7c, 0xbf, 0x55, 0xcc, 0x88, 0xbf, 0xa6, 0x21, 0xb7, 0xab, 0x79, 0xc7, 0x38, 0x60,
	0xe5, 0x58, 0x87, 0x9b, 0x16, 0x5d, 0x8e, 0xdf, 0xe5, 0x12, 0x33, 0xc8, 0x06, 0x7a, 0x09, 0x79,
	0xd7, 0x23, 0x3a, 0x56, 0x59, 0xc2, 0x34, 0xcf, 0xdc, 0xe6, 0xe3, 0xb9, 0x79, 0x32, 0xf2, 0x6e,
	0x04, 0x63, 0x45, 0xa3, 0x3a, 0x9d, 0x94, 0x92, 0x73, 0xc7, 0x36, 0xd4, 0x87, 0x02, 0x97, 0xd5,
	0x3d, 0x1c, 0x51, 0x67, 0x28, 0xb5, 0x74, 0x05, 0xea, 0x6d, 0x0a, 0x88, 0x59, 0xf3, 0xd6, 0x84,
	0x71, 0x82, 0xd6, 0x72, 0x0c, 0x72, 0x30, 0x2c, 0x67, 0xaf, 0x4c, 0xbb, 0x4b, 0x01, 0x97, 0x68,
	0x99, 0xb1, 0x79, 0x03, 0x16, 0x68, 0xac, 0xd8, 0x81, 0x3b, 0xef, 0xcf, 0x0f, 0x49, 0x70, 0x9b,
	0x95, 0xea, 0x7b, 0x12, 0x1c, 0xa9, 0xf8, 0xd4, 0x75, 0x6c, 0x6c, 0x07, 0xb4, 0xa2, 0x59, 0xa5,
	0x44, 0x5d, 0x5f, 0x93, 0xe0, 0xa8, 0xc5, 0x1d, 0xe2, 0x0b, 0x58, 0x66, 0x4c, 0x4d, 0xcd, 0xe7,
	0x14, 0x08, 0xb2, 0xae, 0x46, 0x3c, 0x8a, 0xb9, 0xa9, 0xd0, 0x67, 0xd4, 0x80, 0x15, 0x8b, 0xd8,
	0x2a, 0xa3, 0xd6, 0x8f, 0x34, 0xfb, 0x70, 0x7c, 0x9b, 0x0a, 0x4a, 0xc9, 0x22, 0x36, 0xdd, 0xc9,
	0x36, 0xf5, 0x74, 0x5d, 0x4b, 0x7c, 0x0d, 0xa5, 0xa9, 0x32, 0xa1, 0x2f, 0x21, 0x3b, 0xd0, 0x7c,
	0x4c, 0x99, 0x73, 0x9b, 0x9f, 0x5c, 0xa1, 0x1a, 0xa3, 0x5d, 0x29, 0x14, 0x89, 0x2a, 0xb0, 0x34,
	0xca, 0x29, 0xd2, 0x2e, 0x29, 0xa3, 0xb5, 0xd8, 0x8f, 0x25, 0x27, 0x4a, 0x78, 0x7d, 0x49, 0xf1,
	0x87, 0x34, 0x14, 0xf6, 0x3d, 0xcd, 0xf6, 0x0f, 0xb0, 0xc7, 0x38, 0x5f, 0xc1, 0x8a, 0x8f, 0x6d,
	0x03, 0x7b, 0xea, 0xb8, 0x4f, 0xc5, 0xc7, 0x36, 0xb7, 0xf9, 0xff, 0xa4, 0xc6, 0x44, 0x5b, 0x93,
	0x7a, 0xa3, 0x67, 0xd9, 0xe0, 0x77, 0x18, 0x31, 0xa6, 0x49, 0x0f, 0x32, 0x60, 0xcd, 0xc3, 0x3a,
	0x71, 0x09, 0xb6, 0x83, 0x4b, 0x12, 0xe9, 0x0f, 0x90, 0x58, 0x1d, 0x91, 0x25, 0x54, 0xee, 0xc2,
	0x12, 0x6b, 0xe4, 0xc4, 0xa0, 0xa7, 0xbe, 0xa0, 0xdc, 0xa0, 0x6b, 0xd9, 0x40, 0x77, 0x60, 0x51,
	0xb3, 0xa2, 0x30, 0x7a, 0x6e, 0xb3, 0x0a, 0x5f, 0x89, 0x3f, 0xa7, 0xe1, 0xd6, 0xf3, 0x68, 0x44,
	0xb4, 0x89, 0x69, 0xb2, 0x5a, 0x7c, 0x01, 0x39, 0x4b, 0x3b, 0xc6, 0x9e, 0x4a, 0x47, 0x07, 0x2f,
	0x41, 0x39, 0xb9, 0xbf, 0x68, 0xb4, 0x48, 0x14, 0xc7, 0x77, 0x04, 0x14, 0x42, 0x2d, 0xe8, 0x53,
	0x58, 0x60, 0xd0, 0xf4, 0x7c, 0x68, 0x27, 0xa5, 0xb0, 0x40, 0xf4, 0x1d, 0x94, 0x4c, 0xf2, 0x3a,
	0x24, 0x86, 0x16, 0xcd, 0x12, 0x2e, 0xcc, 0x2e, 0xd8, 0xc3, 0xb9, 0xef, 0xf7, 0xd9, 0x18, 0x15,
	0x53, 0x16, 0xcd, 0x4b, 0x36, 0xb4, 0x01, 0xb9, 0x03, 0x62, 0x9a, 0x2a, 0x2f, 0x40, 0x86, 0x16,
	0x00, 0x22, 0xd3, 0x16, 0xb5, 0x34, 0x0b, 0x90, 0x0b, 0xc6, 0x19, 0x8b, 0x7f, 0x09, 0x50, 0xbc,
	0x4c, 0x8c, 0x9e, 0x01, 0xc4, 0xc4, 0xf8, 0xc3, 0xce, 0xc5, 0x04, 0x1e, 0xd5, 0x20, 0x1f, 0xd5,
	0x41, 0x8d, 0x6e, 0x62, 0x7c, 0x08, 0x0a, 0x0a, 0x44, 0xb6, 0xae, 0x46, 0x3c, 0xd9, 0x98, 0x1a,
	0x86, 0x99, 0xe9, 0x61, 0x78, 0x0f, 0x20, 0x70, 0x02, 0xcd, 0x54, 0x7d, 0x72, 0x86, 0xf9, 0x7b,
	0xbd, 0x49, 0x2d, 0x3d, 0x72, 0x86, 0xd1, 0x2a, 0x2c, 0x12, 0x5f, 0x1d, 0x84, 0xc3, 0xf2, 0x42,
	0x4d, 0xa8, 0x2f, 0x29, 0x0b, 0xc4, 0x6f, 0x86, 0xc3, 0xe8, 0xbe, 0xf9, 0xe1, 0x20, 0x20, 0xfa,
	0xb1, 0x5f, 0x5e, 0xa4, 0x98, 0xd1, 0x5a, 0xfc, 0x25, 0x0d, 0xab, 0xe3, 0x9d, 0x4f, 0x36, 0xa1,
	0xaf, 0xa0, 0x70, 0x8d, 0x9b, 0xa1, 0xe4, 0xfd, 0xc9, 0x73, 0x7a, 0x0c, 0xeb, 0xac, 0xed, 0x1b,
	0xea, 0xf4, 0x97, 0x84, 0x5f, 0xce, 0xd0, 0xe1, 0xf9, 0xf1, 0x6c, 0xea, 0x6e, 0x0c, 0xea, 0x72,
	0x8c, 0x72, 0x97, 0xf3, 0x4d, 0x79, 0x7c, 0xa4, 0xc2, 0x5a, 0x2c, 0x96, 0xfc, 0xca, 0xf1, 0xcb,
	0x59, 0x2a, 0xf4, 0xd1, 0x6c, 0xa1, 0xad, 0x08, 0x30, 0x12, 0x59, 0xe5, 0x3c, 0x09, 0xab, 0xff,
	0x34, 0xbb, 0x94, 0x2e, 0x66, 0xc4, 0xbf, 0xb3, 0x80, 0x7a, 0x81, 0x16, 0xe0, 0x83, 0xd0, 0xa4,
	0x27, 0x86, 0xd5, 0x8d, 0x40, 0x8e, 0x1e, 0x2a, 0xd5, 0x35, 0x35, 0x3d, 0xee, 0x59, 0xed, 0xb9,
	0x67, 0x7a, 0x9a, 0x25, 0x69, 0xea, 0x46, 0x4c, 0x16, 0x1b, 0x26, 0xe0, 0x8c, 0x2c, 0xc8, 0x82,
	0x3c, 0x93, 0xd2, 0x35, 0x5b, 0xc7, 0x26, 0xbf, 0x7d, 0x9d, 0x6b, 0x69, 0x6d, 0x53, 0x2a, 0x7a,
	0x0d, 0xa2, 0x39, 0xeb, 0x8c, 0x6d, 0x28, 0x80, 0x22, 0x93, 0xc3, 0xa7, 0x2e, 0xf1, 0x68, 0x08,
	0x1f, 0xb5, 0x4f, 0xae, 0x25, 0xd9, 0x1a, 0xd1, 0x75, 0x52, 0xca, 0xb2, 0x93, 0x34, 0x55, 0x3a,
	0x70, 0xe7, 0xfd, 0xc5, 0x40, 0x52, 0xdc, 0x75, 0xfe, 0xa5, 0x61, 0xf1, 0x9e, 0x53, 0x19, 0x40,
	0x79, 0x56, 0xaa, 0xa8, 0x0d, 0x25, 0x56, 0x44, 0x6c, 0xb0, 0x9e, 0x30, 0x3e, 0xf1, 0x95, 0x59,
	0xbc, 0xb2, 0xa1, 0x2c, 0xc7, 0x20, 0x6e, 0xa8, 0xa8, 0xb0, 0x36, 0x23, 0x37, 0xb4, 0x03, 0x45,
	0x5a, 0xb8, 0xff, 0xa6, 0x70, 0x8b, 0x63, 0xf8, 0x7a, 0xf4, 0xf9, 0xd0, 0xdc, 0x7e, 0x73, 0x5e,
	0x15, 0xde, 0x9e, 0x57, 0x85, 0x3f, 0xcf, 0xab, 0xc2, 0x4f, 0x17, 0xd5, 0xd4, 0xdb, 0x8b, 0x6a,
	0xea, 0xf7, 0x8b, 0x6a, 0xea, 0xdb, 0xfb, 0x73, 0xbe, 0x73, 0x93, 0x7f, 0x3f, 0x06, 0x8b, 0xd4,
	0xf7, 0xf8, 0x9f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x27, 0x36, 0x5a, 0x79, 0xa4, 0x0c, 0x00, 0x00,
}

func (m *FundingUpdate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FundingUpdate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FundingUpdate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.FundingIndex.Size()
		i -= size
		if _, err := m.FundingIndex.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.FundingValuePpm != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.FundingValuePpm))
		i--
		dAtA[i] = 0x10
	}
	if m.PerpetualId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.PerpetualId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FundingEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FundingEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FundingEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Updates) > 0 {
		for iNdEx := len(m.Updates) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Updates[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEvents(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MarketEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MarketEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MarketEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Event != nil {
		{
			size := m.Event.Size()
			i -= size
			if _, err := m.Event.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.MarketId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.MarketId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MarketEvent_PriceUpdate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MarketEvent_PriceUpdate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PriceUpdate != nil {
		{
			size, err := m.PriceUpdate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *MarketEvent_MarketCreate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MarketEvent_MarketCreate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.MarketCreate != nil {
		{
			size, err := m.MarketCreate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *MarketEvent_MarketModify) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MarketEvent_MarketModify) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.MarketModify != nil {
		{
			size, err := m.MarketModify.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *MarketPriceUpdateEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MarketPriceUpdateEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MarketPriceUpdateEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PriceWithExponent != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.PriceWithExponent))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MarketBaseEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MarketBaseEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MarketBaseEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MinPriceChangePpm != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.MinPriceChangePpm))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Pair) > 0 {
		i -= len(m.Pair)
		copy(dAtA[i:], m.Pair)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Pair)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MarketCreateEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MarketCreateEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MarketCreateEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Exponent != 0 {
		i = encodeVarintEvents(dAtA, i, uint64((uint32(m.Exponent)<<1)^uint32((m.Exponent>>31))))
		i--
		dAtA[i] = 0x10
	}
	if m.Base != nil {
		{
			size, err := m.Base.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MarketModifyEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MarketModifyEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MarketModifyEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Base != nil {
		{
			size, err := m.Base.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TransferEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransferEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransferEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Amount != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.Amount))
		i--
		dAtA[i] = 0x20
	}
	if m.AssetId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.AssetId))
		i--
		dAtA[i] = 0x18
	}
	{
		size, err := m.RecipientSubaccountId.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.SenderSubaccountId.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *OrderFillEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrderFillEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OrderFillEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TakerOrder != nil {
		{
			size := m.TakerOrder.Size()
			i -= size
			if _, err := m.TakerOrder.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.FillAmount != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.FillAmount))
		i--
		dAtA[i] = 0x18
	}
	{
		size, err := m.MakerOrder.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *OrderFillEvent_Order) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OrderFillEvent_Order) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Order != nil {
		{
			size, err := m.Order.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *OrderFillEvent_LiquidationOrder) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OrderFillEvent_LiquidationOrder) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.LiquidationOrder != nil {
		{
			size, err := m.LiquidationOrder.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *LiquidationOrder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LiquidationOrder) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LiquidationOrder) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Subticks != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.Subticks))
		i--
		dAtA[i] = 0x30
	}
	if m.IsBuy {
		i--
		if m.IsBuy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.TotalSize != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.TotalSize))
		i--
		dAtA[i] = 0x20
	}
	if m.PerpetualId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.PerpetualId))
		i--
		dAtA[i] = 0x18
	}
	if m.ClobPairId != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.ClobPairId))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.Liquidated.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintEvents(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *SubaccountUpdateEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubaccountUpdateEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubaccountUpdateEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UpdatedAssetPositions) > 0 {
		for iNdEx := len(m.UpdatedAssetPositions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UpdatedAssetPositions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEvents(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.UpdatedPerpetualPositions) > 0 {
		for iNdEx := len(m.UpdatedPerpetualPositions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UpdatedPerpetualPositions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintEvents(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.SubaccountId != nil {
		{
			size, err := m.SubaccountId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StatefulOrderEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatefulOrderEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StatefulOrderEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Event != nil {
		{
			size := m.Event.Size()
			i -= size
			if _, err := m.Event.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *StatefulOrderEvent_OrderPlace) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StatefulOrderEvent_OrderPlace) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.OrderPlace != nil {
		{
			size, err := m.OrderPlace.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *StatefulOrderEvent_OrderCancel) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StatefulOrderEvent_OrderCancel) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.OrderCancel != nil {
		{
			size, err := m.OrderCancel.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *StatefulOrderEvent_OrderExpiration) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StatefulOrderEvent_OrderExpiration) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.OrderExpiration != nil {
		{
			size, err := m.OrderExpiration.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *StatefulOrderEvent_StatefulOrderPlacement) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatefulOrderEvent_StatefulOrderPlacement) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StatefulOrderEvent_StatefulOrderPlacement) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Order != nil {
		{
			size, err := m.Order.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StatefulOrderEvent_StatefulOrderCancelation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatefulOrderEvent_StatefulOrderCancelation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StatefulOrderEvent_StatefulOrderCancelation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CanceledOrderId != nil {
		{
			size, err := m.CanceledOrderId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StatefulOrderEvent_StatefulOrderExpiration) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatefulOrderEvent_StatefulOrderExpiration) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StatefulOrderEvent_StatefulOrderExpiration) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ExpiredOrderId != nil {
		{
			size, err := m.ExpiredOrderId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintEvents(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintEvents(dAtA []byte, offset int, v uint64) int {
	offset -= sovEvents(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *FundingUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PerpetualId != 0 {
		n += 1 + sovEvents(uint64(m.PerpetualId))
	}
	if m.FundingValuePpm != 0 {
		n += 1 + sovEvents(uint64(m.FundingValuePpm))
	}
	l = m.FundingIndex.Size()
	n += 1 + l + sovEvents(uint64(l))
	return n
}

func (m *FundingEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Updates) > 0 {
		for _, e := range m.Updates {
			l = e.Size()
			n += 1 + l + sovEvents(uint64(l))
		}
	}
	if m.Type != 0 {
		n += 1 + sovEvents(uint64(m.Type))
	}
	return n
}

func (m *MarketEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MarketId != 0 {
		n += 1 + sovEvents(uint64(m.MarketId))
	}
	if m.Event != nil {
		n += m.Event.Size()
	}
	return n
}

func (m *MarketEvent_PriceUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PriceUpdate != nil {
		l = m.PriceUpdate.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}
func (m *MarketEvent_MarketCreate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MarketCreate != nil {
		l = m.MarketCreate.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}
func (m *MarketEvent_MarketModify) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MarketModify != nil {
		l = m.MarketModify.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}
func (m *MarketPriceUpdateEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PriceWithExponent != 0 {
		n += 1 + sovEvents(uint64(m.PriceWithExponent))
	}
	return n
}

func (m *MarketBaseEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Pair)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.MinPriceChangePpm != 0 {
		n += 1 + sovEvents(uint64(m.MinPriceChangePpm))
	}
	return n
}

func (m *MarketCreateEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Base != nil {
		l = m.Base.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.Exponent != 0 {
		n += 1 + sozEvents(uint64(m.Exponent))
	}
	return n
}

func (m *MarketModifyEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Base != nil {
		l = m.Base.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *TransferEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.SenderSubaccountId.Size()
	n += 1 + l + sovEvents(uint64(l))
	l = m.RecipientSubaccountId.Size()
	n += 1 + l + sovEvents(uint64(l))
	if m.AssetId != 0 {
		n += 1 + sovEvents(uint64(m.AssetId))
	}
	if m.Amount != 0 {
		n += 1 + sovEvents(uint64(m.Amount))
	}
	return n
}

func (m *OrderFillEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.MakerOrder.Size()
	n += 1 + l + sovEvents(uint64(l))
	if m.TakerOrder != nil {
		n += m.TakerOrder.Size()
	}
	if m.FillAmount != 0 {
		n += 1 + sovEvents(uint64(m.FillAmount))
	}
	return n
}

func (m *OrderFillEvent_Order) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Order != nil {
		l = m.Order.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}
func (m *OrderFillEvent_LiquidationOrder) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LiquidationOrder != nil {
		l = m.LiquidationOrder.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}
func (m *LiquidationOrder) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Liquidated.Size()
	n += 1 + l + sovEvents(uint64(l))
	if m.ClobPairId != 0 {
		n += 1 + sovEvents(uint64(m.ClobPairId))
	}
	if m.PerpetualId != 0 {
		n += 1 + sovEvents(uint64(m.PerpetualId))
	}
	if m.TotalSize != 0 {
		n += 1 + sovEvents(uint64(m.TotalSize))
	}
	if m.IsBuy {
		n += 2
	}
	if m.Subticks != 0 {
		n += 1 + sovEvents(uint64(m.Subticks))
	}
	return n
}

func (m *SubaccountUpdateEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SubaccountId != nil {
		l = m.SubaccountId.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	if len(m.UpdatedPerpetualPositions) > 0 {
		for _, e := range m.UpdatedPerpetualPositions {
			l = e.Size()
			n += 1 + l + sovEvents(uint64(l))
		}
	}
	if len(m.UpdatedAssetPositions) > 0 {
		for _, e := range m.UpdatedAssetPositions {
			l = e.Size()
			n += 1 + l + sovEvents(uint64(l))
		}
	}
	return n
}

func (m *StatefulOrderEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Event != nil {
		n += m.Event.Size()
	}
	return n
}

func (m *StatefulOrderEvent_OrderPlace) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OrderPlace != nil {
		l = m.OrderPlace.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}
func (m *StatefulOrderEvent_OrderCancel) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OrderCancel != nil {
		l = m.OrderCancel.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}
func (m *StatefulOrderEvent_OrderExpiration) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OrderExpiration != nil {
		l = m.OrderExpiration.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}
func (m *StatefulOrderEvent_StatefulOrderPlacement) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Order != nil {
		l = m.Order.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *StatefulOrderEvent_StatefulOrderCancelation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CanceledOrderId != nil {
		l = m.CanceledOrderId.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *StatefulOrderEvent_StatefulOrderExpiration) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ExpiredOrderId != nil {
		l = m.ExpiredOrderId.Size()
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func sovEvents(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozEvents(x uint64) (n int) {
	return sovEvents(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *FundingUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FundingUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FundingUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PerpetualId", wireType)
			}
			m.PerpetualId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PerpetualId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FundingValuePpm", wireType)
			}
			m.FundingValuePpm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FundingValuePpm |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FundingIndex", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FundingIndex.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FundingEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FundingEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FundingEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Updates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Updates = append(m.Updates, FundingUpdate{})
			if err := m.Updates[len(m.Updates)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= FundingEvent_Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MarketEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MarketEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MarketEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketId", wireType)
			}
			m.MarketId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MarketId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PriceUpdate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MarketPriceUpdateEvent{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Event = &MarketEvent_PriceUpdate{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketCreate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MarketCreateEvent{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Event = &MarketEvent_MarketCreate{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketModify", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MarketModifyEvent{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Event = &MarketEvent_MarketModify{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MarketPriceUpdateEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MarketPriceUpdateEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MarketPriceUpdateEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PriceWithExponent", wireType)
			}
			m.PriceWithExponent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PriceWithExponent |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MarketBaseEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MarketBaseEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MarketBaseEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pair", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pair = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinPriceChangePpm", wireType)
			}
			m.MinPriceChangePpm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinPriceChangePpm |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MarketCreateEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MarketCreateEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MarketCreateEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Base", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Base == nil {
				m.Base = &MarketBaseEvent{}
			}
			if err := m.Base.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exponent", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = int32((uint32(v) >> 1) ^ uint32(((v&1)<<31)>>31))
			m.Exponent = v
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MarketModifyEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MarketModifyEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MarketModifyEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Base", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Base == nil {
				m.Base = &MarketBaseEvent{}
			}
			if err := m.Base.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransferEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransferEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransferEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SenderSubaccountId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SenderSubaccountId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecipientSubaccountId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RecipientSubaccountId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssetId", wireType)
			}
			m.AssetId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AssetId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			m.Amount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Amount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrderFillEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrderFillEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrderFillEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MakerOrder", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MakerOrder.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &types1.Order{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.TakerOrder = &OrderFillEvent_Order{v}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FillAmount", wireType)
			}
			m.FillAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FillAmount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LiquidationOrder", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &LiquidationOrder{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.TakerOrder = &OrderFillEvent_LiquidationOrder{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LiquidationOrder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LiquidationOrder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LiquidationOrder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Liquidated", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Liquidated.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClobPairId", wireType)
			}
			m.ClobPairId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClobPairId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PerpetualId", wireType)
			}
			m.PerpetualId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PerpetualId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalSize", wireType)
			}
			m.TotalSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsBuy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsBuy = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subticks", wireType)
			}
			m.Subticks = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Subticks |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubaccountUpdateEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubaccountUpdateEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubaccountUpdateEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubaccountId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SubaccountId == nil {
				m.SubaccountId = &types.SubaccountId{}
			}
			if err := m.SubaccountId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedPerpetualPositions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpdatedPerpetualPositions = append(m.UpdatedPerpetualPositions, &types.PerpetualPosition{})
			if err := m.UpdatedPerpetualPositions[len(m.UpdatedPerpetualPositions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAssetPositions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpdatedAssetPositions = append(m.UpdatedAssetPositions, &types.AssetPosition{})
			if err := m.UpdatedAssetPositions[len(m.UpdatedAssetPositions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatefulOrderEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StatefulOrderEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StatefulOrderEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderPlace", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &StatefulOrderEvent_StatefulOrderPlacement{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Event = &StatefulOrderEvent_OrderPlace{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderCancel", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &StatefulOrderEvent_StatefulOrderCancelation{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Event = &StatefulOrderEvent_OrderCancel{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderExpiration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &StatefulOrderEvent_StatefulOrderExpiration{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Event = &StatefulOrderEvent_OrderExpiration{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatefulOrderEvent_StatefulOrderPlacement) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StatefulOrderPlacement: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StatefulOrderPlacement: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Order == nil {
				m.Order = &types1.Order{}
			}
			if err := m.Order.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatefulOrderEvent_StatefulOrderCancelation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StatefulOrderCancelation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StatefulOrderCancelation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanceledOrderId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CanceledOrderId == nil {
				m.CanceledOrderId = &types1.OrderId{}
			}
			if err := m.CanceledOrderId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatefulOrderEvent_StatefulOrderExpiration) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StatefulOrderExpiration: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StatefulOrderExpiration: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpiredOrderId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExpiredOrderId == nil {
				m.ExpiredOrderId = &types1.OrderId{}
			}
			if err := m.ExpiredOrderId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipEvents(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthEvents
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupEvents
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthEvents
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthEvents        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowEvents          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupEvents = fmt.Errorf("proto: unexpected end of group")
)
